<html>

<head>
    <title>Particle Editor</title>
    <meta name="viewport"
        content="user-scalable=no, width=device-width, initial-scale=1.0, minimum-scale=1.0,maximum-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="css/style.css">
</head>

<body>
    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="../examples/libs/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                "t3d": "../examples/libs/t3d/build/t3d.module.js",
                "t3d/examples/jsm/": "../examples/libs/t3d/examples/jsm/",
                "t3d-particle": "../build/t3d.particle.module.js"
            }
        }
    </script>

    <script type="module">
        import * as t3d from 't3d';
        import {
        	ParticleGroup, ParticleEmitter, MeshParticleGroup, MeshParticleEmitter
        } from 't3d-particle';
        import { OrbitControls } from 't3d/examples/jsm/controls/OrbitControls.js';
        import { GUI } from './js/lil-gui.esm.min.js';
        import { Texture2DLoader } from 't3d/examples/jsm/loaders/Texture2DLoader.js';
        import { GeometryUtils } from 't3d/examples/jsm/geometries/GeometryUtils.js';
        import { importFileJSON, exportFileJSON } from './js/Utils.js';
        import {
        	ParticleData,
        	ParticleGroupData,
        	ParticleEmitterData,
        	Color,
        	Opacity,
        	Size,
        	Angle
        } from './js/ParticleData.js';

        let width, height, scene, camera, renderer, backRenderTarget, controller;

        let particleGroups = [];
        let particleData = new ParticleData();
        const texArray = {
        	smoke1: new Texture2DLoader().load('../examples/resources/img/smokeparticle.png'),
        	point: new Texture2DLoader().load('https://static.3dmomoda.com/textures/181009160bscjqf1tmbysoz2uvtuvilz.jpg'),
        	fire: new Texture2DLoader().load('https://static.3dmomoda.com/textures/18100916vuhgsdtljucvrysf9wftwufb.jpg'),
        	smoke2: new Texture2DLoader().load('https://static.3dmomoda.com/textures/18100916fmqvpceomi9sxmao1pvicn2n.png'),
        	star: new Texture2DLoader().load('http://static.3dmomoda.com/textures/18092617nyspq5moaka1i2fhvs1hh66s.png'),
        	cloud: new Texture2DLoader().load('../examples/resources/img/cloud.png'),
        	flame: new Texture2DLoader().load('../examples/resources/img/sprite-flame2.jpg')
        };
        const texture = {
        	value: 'smoke1',
        	array: ['smoke1', 'point', 'fire', 'smoke2', 'star', 'cloud', 'flame']
        }

        function init() {
        	width = window.innerWidth || 2;
        	height = window.innerHeight || 2;

        	const canvas = document.createElement('canvas');
        	canvas.width = width;
        	canvas.height = height;
        	document.body.appendChild(canvas);

        	const gl = canvas.getContext("webgl2", {
        		antialias: true,
        		alpha: false,
        		stencil: true
        	});

        	scene = new t3d.Scene();
        	camera = new t3d.Camera();
        	camera.setPerspective(75 / 180 * Math.PI, width / height, 0.1, 10000);
        	camera.position.z = 50;
        	scene.add(camera);
        	scene.fog = new t3d.Fog(undefined, 1, 100);

        	renderer = new t3d.Renderer(gl);
        	renderer.renderPass.state.colorBuffer.setClear(0, 0, 0, 1);
        	backRenderTarget = new t3d.RenderTargetBack(canvas);

        	controller = new OrbitControls(camera, canvas);
        }

        function createParticleGroup(topGui, data) {
        	let particleGroupData = data || new ParticleGroupData();
        	particleData.listGroups.push(particleGroupData);
        	let particleGroup = new ParticleGroup({
        		texture: {
        			value: new Texture2DLoader().load(particleGroupData.texture.url),
        			frames: particleGroupData.texture.vec2Frames,
        			frameCount: particleGroupData.texture.iFrameCount,
        			loop: particleGroupData.texture.iLoop
        		},
        		fixedTimeStep: particleGroupData.fixedTimeStep,
        		hasPerspective: particleGroupData.hasPerspective,
        		colorize: particleGroupData.isColorize,
        		blending: particleGroupData.blendingMode,
        		transparent: particleGroupData.isTransparent,
        		alphaTest: particleGroupData.alphaTest,
        		depthWrite: particleGroupData.isDepthWrite,
        		depthTest: particleGroupData.isDepthTest,
        		fog: particleGroupData.isFog,
        		scale: particleGroupData.scale,
        		maxParticleCount: particleGroupData.maxParticleCount
        	});
        	particleGroups.push(particleGroup);

        	const groupFolder = topGui.addFolder('粒子组');
        	groupFolder.add(texture, 'value', texture.array).name('纹理').onChange(value => {
        		const mat = particleGroup.mesh.material instanceof t3d.ShaderMaterial ? particleGroup.mesh.material : particleGroup.mesh.material[0];
        		mat.uniforms.tex = texArray[value];
        		particleGroupData.texture.name = value;
        		particleGroupData.texture.url = texArray[value].image.attributes.src.nodeValue;
        	});
        	const tex_frame = groupFolder.addFolder('纹理帧').onChange(() => {
        		if (!particleGroupData.useMesh) {
        			particleGroup.textureFrames = particleGroupData.texture.vec2Frames;
        			particleGroup.material.defines["SHOULD_CALCULATE_SPRITE"] = particleGroupData.texture.vec2Frames.x > 1 || particleGroupData.texture.vec2Frames.y > 1;
        			particleGroup.material.uniforms.textureAnimation[0] = particleGroupData.texture.vec2Frames.x;
        			particleGroup.material.uniforms.textureAnimation[1] = particleGroupData.texture.vec2Frames.y;
        			particleGroup.textureFrameCount = particleGroupData.texture.vec2Frames.x * particleGroupData.texture.vec2Frames.y;
        			particleGroup.material.uniforms.textureAnimation[2] = particleGroup.textureFrameCount;
        			particleGroup.textureLoop = particleGroupData.texture.iLoop;
        			particleGroup.material.uniforms.textureAnimation[3] = Math.max(Math.abs(particleGroupData.texture.iLoop), 1.0);
        			particleGroup.material.needsUpdate = true;
        		}
        	}).close();
        	tex_frame.add(particleGroupData.texture.vec2Frames, 'x', 1, 10);
        	tex_frame.add(particleGroupData.texture.vec2Frames, 'y', 1, 10);
        	groupFolder.add(particleGroupData.texture, 'iLoop', 0, 5).name('纹理循环');
        	const useMeshGui = groupFolder.add(particleGroupData, 'useMesh').name('是否启用网格').onChange(value => {
        		particleGroupData.useMesh = value;

        		if (value) {
        			groupFolder.add(particleGroupData, 'meshUrl', ["BuildIn/Box", "BuildIn/Plane", "BuildIn/Sphere"]).name('网格模型').onChange(value => {
        				if (particleGroupData.useMesh) {
        					particleGroupData.meshUrl = value;

        					particleGroup = createMSPEParticleGroup(particleGroupData, particleGroup, groupFolder);

        					particleGroups.push(particleGroup);
        					particleGroup.gui = groupFolder;
        					particleGroupData.listEmitters.forEach((emitterData) => {
        						createEmitter(emitterData, particleGroup, true);
        					});
        					scene.add(particleGroup.mesh);
        				}
        			});

        			particleGroup = createMSPEParticleGroup(particleGroupData, particleGroup);

        			particleGroups.push(particleGroup);
        			particleGroup.gui = groupFolder;
        			particleGroupData.listEmitters.forEach((emitterData) => {
        				createEmitter(emitterData, particleGroup, true);
        			});
        			scene.add(particleGroup.mesh);

        			resetGroupGui(groupFolder);
        			groupFolder.controllers[3].disable();
        		} else {
        			particleGroups.splice(particleGroups.indexOf(particleGroup), 1);
        			particleGroup._emitters.forEach(emitter => {
        				emitter.gui.destroy();
        			})
        			particleGroup.dispose();
        			scene.remove(particleGroup.mesh);
        			particleGroup = null;

        			particleGroup = new ParticleGroup({
        				texture: {
        					value: new Texture2DLoader().load(particleGroupData.texture.url),
        					frames: particleGroupData.texture.vec2Frames,
        					frameCount: particleGroupData.texture.iFrameCount,
        					loop: particleGroupData.texture.iLoop
        				},
        				fixedTimeStep: particleGroupData.fixedTimeStep,
        				hasPerspective: particleGroupData.hasPerspective,
        				colorize: particleGroupData.isColorize,
        				blending: particleGroupData.blendingMode,
        				transparent: particleGroupData.isTransparent,
        				alphaTest: particleGroupData.alphaTest,
        				depthWrite: particleGroupData.isDepthWrite,
        				depthTest: particleGroupData.isDepthTest,
        				fog: particleGroupData.isFog,
        				scale: particleGroupData.scale,
        				maxParticleCount: particleGroupData.maxParticleCount
        			});

        			particleGroups.push(particleGroup);
        			particleGroup.gui = groupFolder;
        			particleGroupData.listEmitters.forEach((emitterData) => {
        				createEmitter(emitterData, particleGroup);
        			});
        			scene.add(particleGroup.mesh);

        			resetGroupGui(groupFolder);
        			groupFolder.controllers[3].enable();
        			groupFolder.controllers[14] && groupFolder.controllers[14].destroy();
        		}
        	});

        	groupFolder.add(particleGroupData, 'hasPerspective').name('透视').onChange(value => {
        		if (!particleGroupData.useMesh) {
        			particleGroup.material.defines["HAS_PERSPECTIVE"] = value;
        			particleGroup.material.needsUpdate = true;
        		}
        	});

        	groupFolder.add(particleGroupData, 'isColorize').name('上色').onChange(value => {
        		if (!particleGroupData.useMesh) {
        			particleGroup.material.defines["COLORIZE"] = value;
        			particleGroup.material.needsUpdate = true;
        		} else {
        			particleGroup._emitters.forEach(emitter => {
        				emitter.SHOULD_COLORIZE_PARTICLES = value;
        			})
        		}
        	});

        	groupFolder.add(particleGroupData, 'isTransparent').name('透明').onChange(value => {
        		if (particleGroupData.useMesh) {
        			particleGroup.mesh.material.transparent = value;
        			particleGroup.mesh.material.needsUpdate = true;
        		} else {
        			particleGroup.material.transparent = value;
        			particleGroup.material.needsUpdate = true;
        		}
        	});

        	groupFolder.add(particleGroupData, 'blendingMode', ["none", "normal", "add", "sub", "mul", "custom"]).name('混合模式').onChange(value => {
        		if (particleGroupData.useMesh) {
        			particleGroup.mesh.material.blending = value;
        			particleGroup.mesh.material.needsUpdate = true;
        		} else {
        			particleGroup.material.blending = value;
        			particleGroup.material.needsUpdate = true;
        		}
        	});

        	groupFolder.add(particleGroupData, 'alphaTest', 0, 1, 0.1).name('alpha测试').onChange(value => {
        		if (particleGroupData.useMesh) {
        			particleGroup.mesh.material.alphaTest = value;
        			particleGroup.mesh.material.needsUpdate = true;
        		} else {
        			particleGroup.material.alphaTest = value;
        			particleGroup.material.needsUpdate = true;
        		}
        	});

        	groupFolder.add(particleGroupData, 'isDepthWrite').name('深度写入').onChange(value => {
        		if (particleGroupData.useMesh) {
        			particleGroup.mesh.material.depthWrite = value;
        			particleGroup.mesh.material.needsUpdate = true;
        		} else {
        			particleGroup.material.depthWrite = value;
        			particleGroup.material.needsUpdate = true;
        		}
        	});

        	groupFolder.add(particleGroupData, 'isDepthTest').name('深度测试').onChange(value => {
        		if (particleGroupData.useMesh) {
        			particleGroup.mesh.material.depthTest = value;
        			particleGroup.mesh.material.needsUpdate = true;
        		} else {
        			particleGroup.material.depthTest = value;
        			particleGroup.material.needsUpdate = true;
        		}
        	});

        	groupFolder.add(particleGroupData, 'isFog').name('是否启用雾').onChange(value => {
        		if (particleGroupData.useMesh) {
        			particleGroup.mesh.material.fog = value;
        			particleGroup.mesh.material.needsUpdate = true;
        		} else {
        			particleGroup.material.fog = value;
        			particleGroup.material.needsUpdate = true;
        		}
        	});

        	groupFolder.add(particleGroupData, 'fixedTimeStep').name('更新频率').onFinishChange(value => {
        		particleGroup.fixedTimeStep = value;
        	});

        	const updateEmitter = {
        		'添加粒子发射器': function() {
        			const emitterData = new ParticleEmitterData();
        			particleGroupData.listEmitters.push(emitterData);
        			createEmitter(emitterData, particleGroup, particleGroupData.useMesh);
        			particleGroup._emitters.length > 1 ? delectEmitter.enable() : delectEmitter.disable();
        		},
        		'删除粒子发射器': function() {
        			const index = particleGroup._emitters.length - 1;
        			particleGroupData.listEmitters.splice(index, 1);
        			const destroyEmitter = particleGroup._emitters[index];
        			destroyEmitter.gui.destroy();
        			particleGroup.removeEmitter(destroyEmitter);
        			particleGroup._emitters.length > 1 ? delectEmitter.enable() : delectEmitter.disable();
        		}
        	}
        	groupFolder.add(updateEmitter, '添加粒子发射器');
        	const delectEmitter = groupFolder.add(updateEmitter, '删除粒子发射器');

        	particleGroup.gui = groupFolder;
        	particleGroupData.listEmitters.forEach((emitterData) => {
        		createEmitter(emitterData, particleGroup);
        	});
        	particleGroup._emitters.length > 1 ? delectEmitter.enable() : delectEmitter.disable();
        	scene.add(particleGroup.mesh);

        	useMeshGui._callOnChange(particleGroupData.useMesh);
        }

        function createMSPEParticleGroup(groupData, particleGroup) {
        	particleGroups.splice(particleGroups.indexOf(particleGroup), 1);
        	let geometry;
        	particleGroup._emitters.forEach(emitter => {
        		emitter.gui.destroy();
        	})
        	particleGroup.dispose();
        	scene.remove(particleGroup.mesh);
        	particleGroup = null;
        	switch (groupData.meshUrl) {
        		case "BuildIn/Plane":
        			const rotationMatrix = new t3d.Matrix4();
        			const euler = new t3d.Euler(Math.PI / 2, 0, 0);
        			const quaternion = new t3d.Quaternion();
        			quaternion.setFromEuler(euler).toMatrix4(rotationMatrix);

        			geometry = new t3d.PlaneGeometry(1, 1);
        			GeometryUtils.applyMatrix4(geometry, rotationMatrix, true);
        			break;
        		case "BuildIn/Box":
        			geometry = new t3d.CubeGeometry(1, 1, 1);
        			break;
        		case "BuildIn/Sphere":
        			geometry = new t3d.SphereGeometry(1, 20, 20);
        			break;
        	}

        	particleGroup = new MeshParticleGroup({
        		texture: {
        			value: new Texture2DLoader().load('../examples/resources/img/smokeparticle.png')
        		},
        		geometry: geometry,
        		fixedTimeStep: groupData.fixedTimeStep,
        		hasPerspective: groupData.hasPerspective,
        		colorize: groupData.isColorize,
        		blending: groupData.blendingMode,
        		transparent: groupData.isTransparent,
        		alphaTest: groupData.alphaTest,
        		depthWrite: groupData.isDepthWrite,
        		depthTest: groupData.isDepthTest,
        		fog: groupData.isFog,
        		scale: groupData.scale,
        		maxParticleCount: groupData.maxParticleCount
        	});
        	return particleGroup;
        }

        function removeParticleGroup() {
        	const index = particleGroups.length - 1;
        	particleGroups[index].dispose();
        	particleData.listGroups.splice(index, 1);
        	scene.remove(particleGroups[index].mesh);
        	particleGroups[index].gui.destroy();
        	particleGroups.splice(index, 1);
        }

        function resetGroupGui(groupGui) {
        	groupGui.controllers[0].reset();
        	groupGui.controllers[1].reset();
        	groupGui.controllers[3].reset();
        	groupGui.controllers[4].reset();
        	groupGui.controllers[5].reset();
        	groupGui.controllers[6].reset();
        	groupGui.controllers[7].reset();
        	groupGui.controllers[8].reset();
        	groupGui.controllers[9].reset();
        	groupGui.controllers[10].reset();
        	groupGui.controllers[11].reset();
        	groupGui.controllers[12].reset();
        	groupGui.folders[0].reset();
        	groupGui.folders[0].controllers[0].reset();
        	groupGui.folders[0].controllers[1].reset();
        }

        function createEmitter(emitterData, group, isMesh = false) {
        	let emitter;
        	parseArrayAttribute(emitterData);
        	const emitterFolder = group.gui.addFolder('粒子发射器');
        	if (isMesh) {
        		emitter = new MeshParticleEmitter(emitterData);

        		// 朝向摄像机
        		emitterFolder.add(emitterData, 'isLookAtCamera').name("朝向摄像机").onChange(value => {
        			emitter.isLookAtCamera = value;
        		});

        		// 锁Y轴
        		emitterFolder.add(emitterData, 'isLookAtCameraOnlyY').name("锁Y轴").onChange(value => {
        			emitter.isLookAtCameraOnlyY = value;
        		});
        	} else {
        		emitter = new ParticleEmitter(emitterData);
        	}

        	group.addEmitter(emitter);

        	emitterFolder.close();

        	// 粒子数
        	emitterFolder.add(emitterData, 'particleCount', 0, 500, 1).name("粒子数").onChange(value => {
        		const emitters = [];
        		for (let i = 0, l = group._emitters.length; i < l; i++) {
        			emitters.push(group._emitters[0]);
        			group.removeEmitter(group._emitters[0]);
        		}
        		emitter.particleCount = value;
        		for (let i = 0; i < emitters.length; i++) {
        			emitters[i].calculatePPSValue();
        			group.addEmitter(emitters[i]);
        		}
        	})

        	// 静态
        	emitterFolder.add(emitterData, 'isStatic').name("静态").onChange(value => {
        		emitter.isStatic = value;
        	});

        	// 方向
        	emitterFolder.add(emitterData, "direction", [1, -1]).name("方向").onChange(value => {
        		emitter.direction = value;
        	})

        	// 发射百分比
        	emitterFolder.add(emitterData, "activeMultiplier", 0, 1).name("发射百分比").onChange(value => {
        		emitter.activeMultiplier = value;
        	})

        	// 最大生命周期
        	const maxAgeFolder = emitterFolder.addFolder('最大生命周期');
        	maxAgeFolder.add(emitterData.maxAge, 'value', 0, 10).name('数值').onFinishChange(value => {
        		emitter.maxAge.value = value;
        	});
        	maxAgeFolder.add(emitterData.maxAge, 'spread', 0, 10).name('方差').onFinishChange(value => {
        		emitter.maxAge.spread = value;
        	});
        	maxAgeFolder.close();

        	let vec3Components = ['x', 'y', 'z'], i;

        	// 位置
        	staticGui({
        		obj: emitterData.position,
        		emitterObj: emitter.position,
        		parentGui: emitterFolder,
        		folderName: '位置', maxValue: 100
        	});

        	// 速度
        	staticGui({
        		obj: emitterData.velocity,
        		emitterObj: emitter.velocity,
        		parentGui: emitterFolder,
        		folderName: '速度', maxValue: 50
        	});

        	// 加速度
        	staticGui({
        		obj: emitterData.acceleration,
        		emitterObj: emitter.acceleration,
        		parentGui: emitterFolder,
        		folderName: '加速度', maxValue: 50
        	});

        	// 阻力
        	const dragFolder = emitterFolder.addFolder('阻力');
        	dragFolder.add(emitterData.drag, 'value', 0, 1).name('数值').onChange(value => {
        		emitter.drag.value = value;
        	});
        	dragFolder.add(emitterData.drag, 'spread', 0, 1).name('方差').onChange(value => {
        		emitter.drag.spread = value;
        	});
        	dragFolder.add(emitterData.drag, 'randomise').name('随机').onChange(value => {
        		emitter.drag.randomise = value;
        	});
        	dragFolder.close();

        	// 旋转
        	const rotationFolder = emitterFolder.addFolder('旋转');
        	const rotationAxisValue = rotationFolder.addFolder('轴向');
        	const rotationAxisSpread = rotationFolder.addFolder('轴向方差');
        	const rotationCenter = rotationFolder.addFolder('中心点');
        	for (i = 0; i < vec3Components.length; ++i) {
        		rotationAxisValue.add(emitterData.rotation.axis, vec3Components[i], 0, 1).listen().onChange(value => {
        			emitter.rotation.axis = emitterData.rotation.axis;
        		});
        		rotationAxisSpread.add(emitterData.rotation.axisSpread, vec3Components[i], 0, 1).listen().onChange(function () {
        			emitter.rotation.axisSpread = emitterData.rotation.axisSpread;
        		});
        		rotationCenter.add(emitterData.rotation.center, vec3Components[i], 0, 100).listen().onChange(function () {
        			emitter.rotation.center = emitterData.rotation.center;
        		});
        	}
        	rotationFolder.add(emitterData.rotation, 'angle', 0, 6.28).name('弧度').onChange(value => {
        		emitter.rotation.angle = value;
        	});
        	rotationFolder.add(emitterData.rotation, 'angleSpread', 0, 6.28).name('弧度方差').onChange(value => {
        		emitter.rotation.angleSpread = value;
        	});
        	rotationFolder.add(emitterData.rotation, 'isStatic').name('静态').onChange(value => {
        		emitter.rotation.static = value;
        	});
        	rotationFolder.add(emitterData.rotation, 'randomise').name('随机').onChange(value => {
        		emitter.rotation.randomise = value;
        	});
        	rotationFolder.close();
        	rotationAxisValue.close();
        	rotationAxisSpread.close();
        	rotationCenter.close();

        	// 颜色
        	dynamicGui({
        		obj: emitterData.listColor,
        		emitterObj: emitter.color,
        		parentGui: emitterFolder,
        		folderName: '颜色',
        	});

        	// 透明度
        	dynamicGui({
        		obj: emitterData.listOpacity,
        		emitterObj: emitter.opacity,
        		parentGui: emitterFolder,
        		folderName: '透明度',
        		minValue: 0,
        		maxValue: 1
        	});

        	// 大小
        	dynamicGui({
        		obj: emitterData.listSize,
        		emitterObj: emitter.size,
        		parentGui: emitterFolder,
        		folderName: '大小',
        		minValue: 0,
        		maxValue: 100
        	});

        	// 角度
        	dynamicGui({
        		obj: emitterData.listAngle,
        		emitterObj: emitter.angle,
        		parentGui: emitterFolder,
        		folderName: '角度',
        		minValue: -6.28,
        		maxValue: 6.28
        	});

        	emitter.gui = emitterFolder;
        }

        function staticGui(params) {
        	const { obj, emitterObj, parentGui, folderName, maxValue } = params;
        	let vec3Components = ['x', 'y', 'z'], i;

        	const folder = parentGui.addFolder(folderName);
        	const valueFolder = folder.addFolder('数值');
        	const spreadFolder = folder.addFolder('方差');
        	folder.add(obj, 'distribution', { BOX: 1, SPHERE: 2, DISC: 3, LINE: 4 }).name('布局').onChange(value => {
        		emitterObj.distribution = value;
        	});
        	for (i = 0; i < vec3Components.length; ++i) {
        		valueFolder.add(obj.value, vec3Components[i], -maxValue, maxValue).listen().onChange(function () {
        			emitterObj.value = obj.value;
        		});
        		spreadFolder.add(obj.spread, vec3Components[i], -maxValue, maxValue).listen().onChange(function () {
        			emitterObj.spread = obj.spread;
        		});
        	}
        	folder.add(obj, 'randomise').name('随机').onChange(value => {
        		emitterObj.randomise = value;
        	});
        	folder.close();
        	valueFolder.close();
        	spreadFolder.close();
        }

        function dynamicGui(params) {
        	const { obj, emitterObj, parentGui, folderName, minValue, maxValue } = params;
        	let vec3Components = ['x', 'y', 'z'], i;

        	const folder = parentGui.addFolder(folderName);
        	const folderParams = {
        		增加: function () {
        			let element = folder.addFolder(folderName + '_' + obj.length);
        			const data = createDynamic(folderName);
        			obj.push(data);

        			const tempArray = [];
        			for (i = 0; i < obj.length; i++) {
        				if (folderName === '颜色') {
        					tempArray.push(new t3d.Color3().setHex(obj[i].value));
        				} else {
        					tempArray.push(obj[i].value);
        				}
        			}
        			emitterObj.value = tempArray;

        			tempArray.length = 0;
        			for (i = 0; i < obj.length; i++) {
        				tempArray.push(obj[i].spread);
        			}
        			emitterObj.spread = tempArray;

        			tempArray.length = 0;
        			for (i = 0; i < obj.length; i++) {
        				tempArray.push(obj[i].randomise);
        			}
        			emitterObj.randomise = tempArray;

        			if (folderName === '颜色') {
        				element.addColor(data, 'value').name('数值').onChange(value => {
        					const tempArray = [];
        					for (i = 0; i < obj.length; i++) {
        						tempArray.push(new t3d.Color3().setHex(obj[i].value));
        					}
        					emitterObj.value = tempArray;
        				});
        				const spreadElement = element.addFolder('方差');
        				for (let j = 0; j < vec3Components.length; ++j) {
        					spreadElement.add(data.spread, vec3Components[j], 0, 1).listen().onChange(function () {
        						const tempArray = [];
        						for (i = 0; i < obj.length; i++) {
        							tempArray.push(obj[i].spread);
        						}
        						emitterObj.spread = tempArray;
        					});
        				}
        				spreadElement.close();
        			} else {
        				element.add(data, 'value', minValue, maxValue).name('数值').onChange(value => {
        					const tempArray = [];
        					for (i = 0; i < obj.length; i++) {
        						tempArray.push(obj[i].value);
        					}
        					emitterObj.value = tempArray;
        				});
        				element.add(data, 'spread', minValue, maxValue).name('方差').onChange(value => {
        					const tempArray = [];
        					for (i = 0; i < obj.length; i++) {
        						tempArray.push(obj[i].spread);
        					}
        					emitterObj.spread = tempArray;
        				});
        			}

        			element.add(data, 'randomise').name('随机').onChange(value => {
        				const tempArray = [];
        				for (i = 0; i < obj.length; i++) {
        					tempArray.push(obj[i].randomise);
        				}
        				emitterObj.randomise = tempArray;
        			});
        			element.close();

        			if (folder.folders.length <= 1) {
        				destroyButton.disable();
        			} else {
        				destroyButton.enable();
        			}
        			if (folder.folders.length >= 4) {
        				newButton.disable();
        			} else {
        				newButton.enable();
        			}
        		},
        		删除: function () {
        			obj.pop();
        			folder.folders[folder.folders.length - 1].destroy();

        			const tempArray = [];
        			for (i = 0; i < obj.length; i++) {
        				if (folderName === '颜色') {
        					tempArray.push(new t3d.Color3().setHex(obj[i].value));
        				} else {
        					tempArray.push(obj[i].value);
        				}
        			}
        			emitterObj.value = tempArray;

        			tempArray.length = 0;
        			for (i = 0; i < obj.length; i++) {
        				tempArray.push(obj[i].spread);
        			}
        			emitterObj.spread = tempArray;

        			tempArray.length = 0;
        			for (i = 0; i < obj.length; i++) {
        				tempArray.push(obj[i].randomise);
        			}
        			emitterObj.randomise = tempArray;

        			if (folder.folders.length <= 1) {
        				destroyButton.disable();
        			} else {
        				destroyButton.enable();
        			}

        			if (folder.folders.length >= 4) {
        				newButton.disable();
        			} else {
        				newButton.enable();
        			}
        		}
        	};

        	const newButton = folder.add(folderParams, '增加');
        	let destroyButton;
        	if (folderName === '颜色') {
        		destroyButton = folder.add(folderParams, '删除');
        		for (let j = 0; j < obj.length; j++) {
        			let element = folder.addFolder('颜色_' + j);
        			const color = obj[j];
        			element.addColor(color, 'value').name('数值').onChange(value => {
        				const tempArray = [];
        				for (i = 0; i < obj.length; i++) {
        					tempArray.push(new t3d.Color3().setHex(obj[i].value));
        				}
        				emitterObj.value = tempArray;
        			});
        			const spreadElement = element.addFolder('方差');
        			for (let j = 0; j < vec3Components.length; ++j) {
        				spreadElement.add(color.spread, vec3Components[j], 0, 1).listen().onChange(function () {
        					const tempArray = [];
        					for (i = 0; i < obj.length; i++) {
        						tempArray.push(obj[i].spread);
        					}
        					emitterObj.spread = tempArray;
        				});
        			}
        			spreadElement.close();
        			element.add(color, 'randomise').name('随机').onChange(value => {
        				const tempArray = [];
        				for (i = 0; i < obj.length; i++) {
        					tempArray.push(obj[i].randomise);
        				}
        				emitterObj.randomise = tempArray;
        			});
        			element.close();
        		}
        	} else {
        		destroyButton = folder.add(folderParams, '删除').disable();
        		let element = folder.addFolder(folderName + '_0');
        		element.add(obj[0], 'value', minValue, maxValue).name('数值').onChange(value => {
        			const tempArray = [];
        			for (i = 0; i < obj.length; i++) {
        				tempArray.push(obj[i].value);
        			}
        			emitterObj.value = tempArray;
        		});
        		element.add(obj[0], 'spread', minValue, maxValue).name('方差').onChange(value => {
        			const tempArray = [];
        			for (i = 0; i < obj.length; i++) {
        				tempArray.push(obj[i].spread);
        			}
        			emitterObj.spread = tempArray;
        		});
        		element.add(obj[0], 'randomise').name('随机').onChange(value => {
        			const tempArray = [];
        			for (i = 0; i < obj.length; i++) {
        				tempArray.push(obj[i].randomise);
        			}
        			emitterObj.randomise = tempArray;
        		});
        		element.close();
        	}
        	folder.close();
        }

        function parseArrayAttribute(emitterData) {
        	const colorLen = emitterData.listColor.length;
        	const colorValue = [], colorSpread = [], colorRandomise = [];
        	for (let i = 0; i < colorLen; i++) {
        		colorValue.push(new t3d.Color3().setHex(emitterData.listColor[i].value));
        		colorSpread.push(emitterData.listColor[i].spread);
        		colorRandomise.push(emitterData.listColor[i].randomise);
        	}
        	emitterData.color = {
        		value: colorValue,
        		spread: colorSpread,
        		randomise: colorRandomise
        	}
        	const opacityLen = emitterData.listOpacity.length;
        	const opacityValue = [], opacitySpread = [], opacityRandomise = [];
        	for (let i = 0; i < opacityLen; i++) {
        		opacityValue.push(emitterData.listOpacity[i].value);
        		opacitySpread.push(emitterData.listOpacity[i].spread);
        		opacityRandomise.push(emitterData.listOpacity[i].randomise);
        	}
        	emitterData.opacity = {
        		value: opacityValue,
        		spread: opacitySpread,
        		randomise: opacityRandomise
        	}
        	const sizeLen = emitterData.listSize.length;
        	const sizeValue = [], sizeSpread = [], sizeRandomise = [];
        	for (let i = 0; i < sizeLen; i++) {
        		sizeValue.push(emitterData.listSize[i].value);
        		sizeSpread.push(emitterData.listSize[i].spread);
        		sizeRandomise.push(emitterData.listSize[i].randomise);
        	}
        	emitterData.size = {
        		value: sizeValue,
        		spread: sizeSpread,
        		randomise: sizeRandomise
        	}
        	const angleLen = emitterData.listAngle.length;
        	const angleValue = [], angleSpread = [], angleRandomise = [];
        	for (let i = 0; i < angleLen; i++) {
        		angleValue.push(emitterData.listAngle[i].value);
        		angleSpread.push(emitterData.listAngle[i].spread);
        		angleRandomise.push(emitterData.listAngle[i].randomise);
        	}
        	emitterData.angle = {
        		value: angleValue,
        		spread: angleSpread,
        		randomise: angleRandomise
        	}
        }

        function createDynamic(type) {
        	switch (type) {
        		case '颜色':
        			return new Color();
        		case '透明度':
        			return new Opacity();
        		case '大小':
        			return new Size();
        		case '角度':
        			return new Angle();
        	}
        }

        function convertVector(data) {
        	data.forEach(groupData => {
        		groupData.texture.vec2Frames = new t3d.Vector2(groupData.texture.vec2Frames.x, groupData.texture.vec2Frames.y);
        		groupData.listEmitters.forEach(emitterData => {
        			emitterData.position.value = new t3d.Vector3().copy(emitterData.position.value);
        			emitterData.position.spread = new t3d.Vector3().copy(emitterData.position.spread);
        			emitterData.position.spreadClamp = new t3d.Vector3().copy(emitterData.position.spreadClamp);
        			emitterData.position.radiusScale = new t3d.Vector3().copy(emitterData.position.radiusScale);

        			emitterData.velocity.value = new t3d.Vector3().copy(emitterData.velocity.value);
        			emitterData.velocity.spread = new t3d.Vector3().copy(emitterData.velocity.spread);

        			emitterData.acceleration.value = new t3d.Vector3().copy(emitterData.acceleration.value);
        			emitterData.acceleration.spread = new t3d.Vector3().copy(emitterData.acceleration.spread);

        			emitterData.rotation.axis = new t3d.Vector3().copy(emitterData.rotation.axis);
        			emitterData.rotation.axisSpread = new t3d.Vector3().copy(emitterData.rotation.axisSpread);
        			emitterData.rotation.center = new t3d.Vector3().copy(emitterData.rotation.center);

        			emitterData.listColor.forEach(color => {
        				color.spread = new t3d.Vector3().copy(color.spread);
        			})
        		})
        	});

        	return data;
        }

        function initGUI() {
        	const gui = new GUI();

        	const initParams = {
        		新建粒子组: function () {
        			createParticleGroup(gui);
        			destroyParticleGroupButton.enable();
        			exportDataButton.enable();
        		},
        		删除粒子组: function () {
        			removeParticleGroup();
        			!particleGroups.length && destroyParticleGroupButton.disable();
        			newParticleGroupButton.enable();
        			!particleGroups.length && exportDataButton.disable();
        		},
        		导入粒子数据: function() {
        			importFileJSON(data => {
        				let length = particleGroups.length;
        				for (let i = 0; i < length; i++) {
        					removeParticleGroup();
        				}
        				data = convertVector(data);
        				data.forEach((groupData) => {
        					createParticleGroup(gui, groupData);
        				})
        				if (data.length > 1) {
        					destroyParticleGroupButton.enable();
        				} else {
        					destroyParticleGroupButton.disable();
        				}
        				exportDataButton.enable();
        			});
        		},
        		导出粒子数据: function () {
        			exportFileJSON(particleData.getData());
        		}
        	};

        	const newParticleGroupButton = gui.add(initParams, '新建粒子组');
        	const destroyParticleGroupButton = gui.add(initParams, '删除粒子组').disable();
        	const importDataButton = gui.add(initParams, '导入粒子数据');
        	const exportDataButton = gui.add(initParams, '导出粒子数据').disable();
        }

        function animate() {
        	requestAnimationFrame(animate);

        	controller.update();

        	if (particleGroups.length) {
        		particleGroups.forEach(particleGroup => {
        			particleGroup.tick(particleGroup.fixedTimeStep, camera);
        		})
        	}

        	scene.updateMatrix();
        	scene.updateRenderStates(camera);
        	scene.updateRenderQueue(camera);

        	renderer.renderPass.renderTarget.setRenderTarget(backRenderTarget);
        	renderer.renderPass.clear(true, true, false);
        	renderer.renderScene(scene, camera);
        }

        init();
        initGUI();

        setTimeout(animate, 0);

        function onWindowResize() {
        	width = window.innerWidth || 2;
        	height = window.innerHeight || 2;

        	camera.setPerspective(75 / 180 * Math.PI, width / height, 0.1, 10000);

        	backRenderTarget.resize(width, height);
        }

        window.addEventListener("resize", onWindowResize, false);
    </script>
</body>

</html>