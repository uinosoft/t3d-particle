// t3d-particle
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("t3d")):"function"==typeof define&&define.amd?define(["exports","t3d"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).t3d=t.t3d||{},t.t3d)}(this,(function(t,e){"use strict";function i(t){var e=Object.create(null);return t&&Object.keys(t).forEach((function(i){if("default"!==i){var r=Object.getOwnPropertyDescriptor(t,i);Object.defineProperty(e,i,r.get?r:{enumerable:!0,get:function(){return t[i]}})}})),e.default=t,Object.freeze(e)}var r=i(e);const a={distributions:{BOX:1,SPHERE:2,DISC:3,LINE:4},valueOverLifetimeLength:4},o={types:{BOOLEAN:"boolean",STRING:"string",NUMBER:"number",OBJECT:"object"},ensureTypedArg:function(t,e,i){return typeof t===e?t:i},ensureArrayTypedArg:function(t,e,i){if(Array.isArray(t)){for(let r=t.length-1;r>=0;--r)if(typeof t[r]!==e)return i;return t}return this.ensureTypedArg(t,e,i)},ensureInstanceOf:function(t,e,i){return void 0!==e&&t instanceof e?t:i},ensureArrayInstanceOf:function(t,e,i){if(Array.isArray(t)){for(let r=t.length-1;r>=0;--r)if(void 0!==e&&t[r]instanceof e==!1)return i;return t}return this.ensureInstanceOf(t,e,i)},ensureValueOverLifetimeCompliance:function(t,e,i){e=e||3,i=i||3,!1===Array.isArray(t._value)&&(t._value=[t._value]),!1===Array.isArray(t._spread)&&(t._spread=[t._spread]);const r=this.clamp(t._value.length,e,i),a=this.clamp(t._spread.length,e,i),o=Math.max(r,a);t._value.length!==o&&(t._value=this.interpolateArray(t._value,o)),t._spread.length!==o&&(t._spread=this.interpolateArray(t._spread,o))},interpolateArray:function(t,e){const i=t.length,r=["function"==typeof t[0].clone?t[0].clone():t[0]],a=(i-1)/(e-1);for(let i=1;i<e-1;i++){const e=i*a,o=Math.floor(e),s=Math.ceil(e),n=e-o;r[i]=this.lerpTypeAgnostic(t[o],t[s],n)}return r.push("function"==typeof t[i-1].clone?t[i-1].clone():t[i-1]),r},clamp:function(t,e,i){return Math.max(e,Math.min(t,i))},zeroToEpsilon:function(t,e){const i=1e-5;let r=t;return r=e?Math.random()*i*10:i,t<0&&t>-1e-5&&(r=-r),r},lerpTypeAgnostic:function(t,e,i){const a=this.types;let o;return typeof t===a.NUMBER&&typeof e===a.NUMBER?this.lerp(t,e,i):t instanceof r.Vector2&&e instanceof r.Vector2||typeof t.x==a.NUMBER&&typeof t.y==a.NUMBER&&null==t.z&&null==t.z&&typeof e.x==a.NUMBER&&typeof e.y==a.NUMBER&&null==e.z&&null==e.z?(o=t instanceof r.Vector2?new r.Vector2:{},o.x=this.lerp(t.x,e.x,i),o.y=this.lerp(t.y,e.y,i),o):t instanceof r.Vector3&&e instanceof r.Vector3||typeof t.x==a.NUMBER&&typeof t.y==a.NUMBER&&typeof t.z==a.NUMBER&&null==t.w&&null==t.w&&typeof e.x==a.NUMBER&&typeof e.y==a.NUMBER&&typeof e.z==a.NUMBER&&null==e.w&&null==e.w?(o=t instanceof r.Vector3?new r.Vector3:{},o.x=this.lerp(t.x,e.x,i),o.y=this.lerp(t.y,e.y,i),o.z=this.lerp(t.z,e.z,i),o):t instanceof r.Vector4&&e instanceof r.Vector4||typeof t.x==a.NUMBER&&typeof t.y==a.NUMBER&&typeof t.z==a.NUMBER&&typeof t.w==a.NUMBER&&typeof e.x==a.NUMBER&&typeof e.y==a.NUMBER&&typeof e.z==a.NUMBER&&typeof e.w==a.NUMBER?(o=t instanceof r.Vector4?new r.Vector4:{},o.x=this.lerp(t.x,e.x,i),o.y=this.lerp(t.y,e.y,i),o.z=this.lerp(t.z,e.z,i),o.w=this.lerp(t.w,e.w,i),o):t instanceof r.Color3&&e instanceof r.Color3||typeof t.r==a.NUMBER&&typeof t.g==a.NUMBER&&typeof t.b==a.NUMBER&&typeof e.r==a.NUMBER&&typeof e.g==a.NUMBER&&typeof e.b==a.NUMBER?(o=t instanceof r.Color3?new r.Color3:{},o.r=this.lerp(t.r,e.r,i),o.g=this.lerp(t.g,e.g,i),o.b=this.lerp(t.b,e.b,i),o):void console.warn("Invalid argument types, or argument types do not match:",t,e)},lerp:function(t,e,i){return t+(e-t)*i},hasNonZeroElement:function(t){return t.some((t=>0!==t))},roundToNearestMultiple:function(t,e){let i=0;return 0===e?t:(i=Math.abs(t)%e,0===i?t:t<0?-(Math.abs(t)-i):t+e-i)},arrayValuesAreEqual:function(t){for(let e=0;e<t.length-1;++e)if(t[e]!==t[e+1])return!1;return!0},randomFloat:function(t,e){return t+e*(Math.random()-.5)},getRandomVector3:function(t,e,i,r,a){let s=i.x+(Math.random()*r.x-.5*r.x),n=i.y+(Math.random()*r.y-.5*r.y),l=i.z+(Math.random()*r.z-.5*r.z);return a&&a.x&&(s=.5*-a.x+o.roundToNearestMultiple(s,a.x),n=.5*-a.y+o.roundToNearestMultiple(n,a.y),l=.5*-a.z+o.roundToNearestMultiple(l,a.z)),t[e+0]=s,t[e+1]=n,t[e+2]=l,t},getRandomVector3OnSphere:function(t,e,i,r,a,s,n){const l=2*Math.random()-1,u=6.2832*Math.random(),c=Math.sqrt(1-l*l);let h=o.randomFloat(s,r.x),f=0,p=0,d=0;return a.x&&(h=Math.round(h/a.x)*a.x),f=c*Math.cos(u)*h,p=c*Math.sin(u)*h,d=l*h,f*=n.x,p*=n.y,d*=n.z,f+=i.x,p+=i.y,d+=i.z,t[e+0]=f,t[e+1]=p,t[e+2]=d,t},getRandomVector3OnDisc:function(t,e,i,r,a,s,n){const l=6.2832*Math.random();let u=Math.abs(o.randomFloat(s,r.x)),c=0,h=0,f=0;return a.x&&(u=Math.round(u/a.x)*a.x),c=Math.cos(l)*u,h=Math.sin(l)*u,c*=n.x,h*=n.y,c+=i.x,h+=i.y,f+=i.z,t[e+0]=c,t[e+1]=h,t[e+2]=f,t},getRandomVector3OnLine:function(){const t=new r.Vector3;return function(e,i,r,a){return t.lerpVectors(r,a,Math.random()),t.toArray(e,i),e}}(),getRandomDirectionVector3OnSphere:function(){const t=new r.Vector3;return function(e,i,r,a,s,n,l,u){return t.copy(u),t.x-=s,t.y-=n,t.z-=l,t.normalize().multiplyScalar(-o.randomFloat(r.x,a.x)),t.toArray(e,i),e}}(),getRandomDirectionVector3OnDisc:function(){const t=new r.Vector3;return function(e,i,r,a,s,n,l,u){return t.copy(u),t.x-=s,t.y-=n,t.z-=l,t.normalize().multiplyScalar(-o.randomFloat(r.x,a.x)),t.toArray(e,i),e[i+2]=0,e}}(),getRotationAxis:function(){const t=new r.Vector3;return function(e,i,r){return e.copy(i).normalize(),t.copy(r).normalize(),e.x+=.5*-r.x+Math.random()*r.x,e.y+=.5*-r.y+Math.random()*r.y,e.z+=.5*-r.z+Math.random()*r.z,e.normalize(),e}}()},s={defines:["#define PACKED_COLOR_SIZE 256.0","#define PACKED_COLOR_DIVISOR 255.0"].join("\n"),uniforms:["uniform float deltaTime;","uniform float runTime;","uniform sampler2D tex;","uniform vec4 textureAnimation;","uniform float scale;"].join("\n"),attributes:["attribute vec4 acceleration;","attribute vec3 velocity;","attribute vec4 rotation;","attribute vec3 rotationCenter;","attribute vec4 params;","attribute vec4 size;","attribute vec4 angle;","attribute vec4 color;","attribute vec4 opacity;"].join("\n"),varyings:["varying vec4 vColor;","#ifdef SHOULD_ROTATE_TEXTURE","\t\tvarying float vAngle;","#endif","#ifdef SHOULD_CALCULATE_SPRITE","\t\tvarying vec4 vSpriteSheet;","#endif"].join("\n"),branchAvoidanceFunctions:["float when_gt(float x, float y) {","\t\treturn max(sign(x - y), 0.0);","}","float when_lt(float x, float y) {","\t\treturn min( max(1.0 - sign(x - y), 0.0), 1.0 );","}","float when_eq( float x, float y ) {","\t\treturn 1.0 - abs( sign( x - y ) );","}","float when_ge(float x, float y) {","\treturn 1.0 - when_lt(x, y);","}","float when_le(float x, float y) {","\treturn 1.0 - when_gt(x, y);","}","float and(float a, float b) {","\t\treturn a * b;","}","float or(float a, float b) {","\t\treturn min(a + b, 1.0);","}"].join("\n"),unpackColor:["vec3 unpackColor( in float hex ) {","\t vec3 c = vec3( 0.0 );","\t float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );","\t float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );","\t float b = mod( hex, PACKED_COLOR_SIZE );","\t c.r = r / PACKED_COLOR_DIVISOR;","\t c.g = g / PACKED_COLOR_DIVISOR;","\t c.b = b / PACKED_COLOR_DIVISOR;","\t return c;","}"].join("\n"),unpackRotationAxis:["vec3 unpackRotationAxis( in float hex ) {","\t vec3 c = vec3( 0.0 );","\t float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );","\t float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );","\t float b = mod( hex, PACKED_COLOR_SIZE );","\t c.r = r / PACKED_COLOR_DIVISOR;","\t c.g = g / PACKED_COLOR_DIVISOR;","\t c.b = b / PACKED_COLOR_DIVISOR;","\t c *= vec3( 2.0 );","\t c -= vec3( 1.0 );","\t return c;","}"].join("\n"),floatOverLifetime:["float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {","\t\thighp float value = 0.0;","\t\tfloat deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH - 1 );","\t\tfloat fIndex = 0.0;","\t\tfloat shouldApplyValue = 0.0;","\t\tvalue += attr[ 0 ] * when_eq( deltaAge, 0.0 );","","\t\tfor( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {","\t\t\t fIndex = float( i );","\t\t\t shouldApplyValue = and( when_gt( deltaAge, fIndex ), when_le( deltaAge, fIndex + 1.0 ) );","\t\t\t value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );","\t\t}","","\t\treturn value;","}"].join("\n"),colorOverLifetime:["vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {","\t\tvec3 value = vec3( 0.0 );","\t\tvalue.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );","\t\tvalue.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );","\t\tvalue.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );","\t\treturn value;","}"].join("\n"),paramFetchingFunctions:["float getAlive() {","\t return params.x;","}","float getAge() {","\t return params.y;","}","float getMaxAge() {","\t return params.z;","}","float getWiggle() {","\t return params.w;","}"].join("\n"),forceFetchingFunctions:["vec4 getPosition( in float age ) {","\t return u_View * u_Model * vec4( a_Position, 1.0 );","}","vec3 getVelocity( in float age ) {","\t return velocity * age;","}","vec3 getAcceleration( in float age ) {","\t return acceleration.xyz * age;","}"].join("\n"),rotationFunctions:["#ifdef SHOULD_ROTATE_PARTICLES","\t mat4 getRotationMatrix( in vec3 axis, in float angle) {","\t\t\t axis = normalize(axis);","\t\t\t float s = sin(angle);","\t\t\t float c = cos(angle);","\t\t\t float oc = 1.0 - c;","","\t\t\t return mat4(oc * axis.x * axis.x + c,\t\t\t\t\t oc * axis.x * axis.y - axis.z * s,\toc * axis.z * axis.x + axis.y * s,\t0.0,","\t\t\t\t\t\t\t\t\t oc * axis.x * axis.y + axis.z * s,\toc * axis.y * axis.y + c,\t\t\t\t\t oc * axis.y * axis.z - axis.x * s,\t0.0,","\t\t\t\t\t\t\t\t\t oc * axis.z * axis.x - axis.y * s,\toc * axis.y * axis.z + axis.x * s,\toc * axis.z * axis.z + c,\t\t\t\t\t 0.0,","\t\t\t\t\t\t\t\t\t 0.0,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t0.0,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t0.0,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1.0);","\t }","","\t vec3 getRotation( in vec3 pos, in float positionInTime ) {","\t\t\tif( rotation.y == 0.0 ) {","\t\t\t\t\t return pos;","\t\t\t}","","\t\t\tvec3 axis = unpackRotationAxis( rotation.x );","\t\t\tvec3 center = rotationCenter;","\t\t\tvec3 translated;","\t\t\tmat4 rotationMatrix;","\t\t\tfloat angle = 0.0;","\t\t\tangle += when_eq( rotation.z, 0.0 ) * rotation.y;","\t\t\tangle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime );","\t\t\ttranslated = rotationCenter - pos;","\t\t\trotationMatrix = getRotationMatrix( axis, angle );","\t\t\treturn center - vec3( rotationMatrix * vec4( translated, 0.0 ) );","\t }","#endif"].join("\n"),rotateTexture:["\t\tvec2 vUv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );","","\t\t#ifdef SHOULD_CALCULATE_SPRITE","\t\t\t\tfloat framesX = vSpriteSheet.x;","\t\t\t\tfloat framesY = vSpriteSheet.y;","\t\t\t\tfloat columnNorm = vSpriteSheet.z;","\t\t\t\tfloat rowNorm = vSpriteSheet.w;","\t\t\t\tvUv.x = gl_PointCoord.x * framesX + columnNorm;","\t\t\t\tvUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);","\t\t#endif","\t\t#ifdef SHOULD_ROTATE_TEXTURE","\t\t\t#ifdef SHOULD_CALCULATE_SPRITE","\t\t\t\t\t float x = vUv.x - framesX * 0.5 - columnNorm;","\t\t\t\t\t float y = vUv.y - ( 1.0 - rowNorm ) + framesY * 0.5;","\t\t\t\t\t float c = cos( -vAngle );","\t\t\t\t\t float s = sin( -vAngle );","\t\t\t\t\t vUv = vec2( c * x + s * y + framesX * 0.5 + columnNorm, c * y - s * x + ( 1.0 - rowNorm ) - framesY * 0.5 );","\t\t#else","\t\t\t\t\t float x = vUv.x - 0.5;","\t\t\t\t\t float y = vUv.y - 0.5;","\t\t\t\t\t float c = cos( -vAngle );","\t\t\t\t\t float s = sin( -vAngle );","\t\t\t\t\t vUv = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );","\t\t#endif","\t\t#endif","","","\t\tvec4 rotatedTexture = texture2D( tex, vUv );"].join("\n")},n={vertex:[s.defines,s.uniforms,s.attributes,s.varyings,r.ShaderChunk.common_vert,r.ShaderChunk.logdepthbuf_pars_vert,s.branchAvoidanceFunctions,s.unpackColor,s.unpackRotationAxis,s.floatOverLifetime,s.colorOverLifetime,s.paramFetchingFunctions,s.forceFetchingFunctions,s.rotationFunctions,"void main() {","\t\thighp float age = getAge();","\t\thighp float alive = getAlive();","\t\thighp float maxAge = getMaxAge();","\t\thighp float positionInTime = (age / maxAge);","\t\thighp float isAlive = when_gt( alive, 0.0 );","\t\t#ifdef SHOULD_WIGGLE_PARTICLES","\t\t\t\tfloat wiggleAmount = positionInTime * getWiggle();","\t\t\t\tfloat wiggleSin = isAlive * sin( wiggleAmount );","\t\t\t\tfloat wiggleCos = isAlive * cos( wiggleAmount );","\t\t#endif","\t\tvec3 vel = getVelocity( age );","\t\tvec3 accel = getAcceleration( age );","\t\tvec3 force = vec3( 0.0 );","\t\tvec3 pos = vec3( a_Position );","\t\tfloat drag = 1.0 - (positionInTime * 0.5) * acceleration.w;","\t\tforce += vel;","\t\tforce *= drag;","\t\tforce += accel * age;","\t\tpos += force;","\t\t#ifdef SHOULD_WIGGLE_PARTICLES","\t\t\t\tpos.x += wiggleSin;","\t\t\t\tpos.y += wiggleCos;","\t\t\t\tpos.z += wiggleSin;","\t\t#endif","\t\t#ifdef SHOULD_ROTATE_PARTICLES","\t\t\t\tpos = getRotation( pos, positionInTime );","\t\t#endif","\t\tvec4 mvPosition = u_View * u_Model * vec4( pos, 1.0 );","\t\thighp float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;","\t\t#ifdef HAS_PERSPECTIVE","\t\t\t\tfloat perspective = scale / length( mvPosition.xyz );","\t\t#else","\t\t\t\tfloat perspective = 1.0;","\t\t#endif","\t\tfloat pointSizePerspective = pointSize * perspective;","\t\t#ifdef COLORIZE","\t\t\t vec3 c = isAlive * getColorOverLifetime(","\t\t\t\t\t positionInTime,","\t\t\t\t\t unpackColor( color.x ),","\t\t\t\t\t unpackColor( color.y ),","\t\t\t\t\t unpackColor( color.z ),","\t\t\t\t\t unpackColor( color.w )","\t\t\t );","\t\t#else","\t\t\t vec3 c = vec3(1.0);","\t\t#endif","\t\tfloat o = isAlive * getFloatOverLifetime( positionInTime, opacity );","\t\tvColor = vec4( c, o );","\t\t#ifdef SHOULD_ROTATE_TEXTURE","\t\t\t\tvAngle = isAlive * getFloatOverLifetime( positionInTime, angle );","\t\t#endif","\t\t#ifdef SHOULD_CALCULATE_SPRITE","\t\t\t\tfloat framesX = textureAnimation.x;","\t\t\t\tfloat framesY = textureAnimation.y;","\t\t\t\tfloat loopCount = textureAnimation.w;","\t\t\t\tfloat totalFrames = textureAnimation.z;","\t\t\t\tfloat frameNumber = mod( (positionInTime * loopCount) * totalFrames, totalFrames );","\t\t\t\tfloat column = floor(mod( frameNumber, framesX ));","\t\t\t\tfloat row = floor( (frameNumber - column) / framesX );","\t\t\t\tfloat columnNorm = column / framesX;","\t\t\t\tfloat rowNorm = row / framesY;","\t\t\t\tvSpriteSheet.x = 1.0 / framesX;","\t\t\t\tvSpriteSheet.y = 1.0 / framesY;","\t\t\t\tvSpriteSheet.z = columnNorm;","\t\t\t\tvSpriteSheet.w = rowNorm;","\t\t#endif","\t\tgl_PointSize = pointSizePerspective;","\t\tgl_Position = u_Projection * mvPosition;",r.ShaderChunk.logdepthbuf_vert,"}"].join("\n"),fragment:[s.uniforms,r.ShaderChunk.common_frag,r.ShaderChunk.fog_pars_frag,r.ShaderChunk.logdepthbuf_pars_frag,s.varyings,s.branchAvoidanceFunctions,"void main() {","\t\tvec3 outgoingLight = vColor.xyz;","\t\t","\t\t#ifdef ALPHATEST","\t\t\t if ( vColor.w < float(ALPHATEST) ) discard;","\t\t#endif",s.rotateTexture,r.ShaderChunk.logdepthbuf_frag,"\t\toutgoingLight = vColor.xyz * rotatedTexture.xyz;","\t\tgl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );",r.ShaderChunk.fog_frag,"}"].join("\n")};class l{constructor(t){this.uuid=r.generateUUID();const e=o.types,i=a.valueOverLifetimeLength;(t=o.ensureTypedArg(t,e.OBJECT,{})).position=o.ensureTypedArg(t.position,e.OBJECT,{}),t.velocity=o.ensureTypedArg(t.velocity,e.OBJECT,{}),t.acceleration=o.ensureTypedArg(t.acceleration,e.OBJECT,{}),t.radius=o.ensureTypedArg(t.radius,e.OBJECT,{}),t.drag=o.ensureTypedArg(t.drag,e.OBJECT,{}),t.rotation=o.ensureTypedArg(t.rotation,e.OBJECT,{}),t.color=o.ensureTypedArg(t.color,e.OBJECT,{}),t.opacity=o.ensureTypedArg(t.opacity,e.OBJECT,{}),t.size=o.ensureTypedArg(t.size,e.OBJECT,{}),t.angle=o.ensureTypedArg(t.angle,e.OBJECT,{}),t.wiggle=o.ensureTypedArg(t.wiggle,e.OBJECT,{}),t.maxAge=o.ensureTypedArg(t.maxAge,e.OBJECT,{}),this.type=o.ensureTypedArg(t.type,e.NUMBER,a.distributions.BOX),this.position={_value:o.ensureInstanceOf(t.position.value,r.Vector3,new r.Vector3),_spread:o.ensureInstanceOf(t.position.spread,r.Vector3,new r.Vector3),_spreadClamp:o.ensureInstanceOf(t.position.spreadClamp,r.Vector3,new r.Vector3),_distribution:t.position.distribution||this.type,_randomise:o.ensureTypedArg(t.position.randomise,e.BOOLEAN,!1),_radius:o.ensureTypedArg(t.position.radius,e.NUMBER,10),_radiusScale:o.ensureInstanceOf(t.position.radiusScale,r.Vector3,new r.Vector3(1,1,1))},this._setDistributeFunctions("position",this.position._distribution),this.velocity={_value:o.ensureInstanceOf(t.velocity.value,r.Vector3,new r.Vector3),_spread:o.ensureInstanceOf(t.velocity.spread,r.Vector3,new r.Vector3),_distribution:t.velocity.distribution||this.type,_randomise:o.ensureTypedArg(t.velocity.randomise,e.BOOLEAN,!1)},this._setDistributeFunctions("velocity",this.velocity._distribution),this.acceleration={_value:o.ensureInstanceOf(t.acceleration.value,r.Vector3,new r.Vector3),_spread:o.ensureInstanceOf(t.acceleration.spread,r.Vector3,new r.Vector3),_distribution:t.acceleration.distribution||this.type,_randomise:o.ensureTypedArg(t.acceleration.randomise,e.BOOLEAN,!1)},this._setDistributeFunctions("acceleration",this.acceleration._distribution),this.drag={_value:o.ensureTypedArg(t.drag.value,e.NUMBER,0),_spread:o.ensureTypedArg(t.drag.spread,e.NUMBER,0),_randomise:o.ensureTypedArg(t.drag.randomise,e.BOOLEAN,!1)},this.wiggle={_value:o.ensureTypedArg(t.wiggle.value,e.NUMBER,0),_spread:o.ensureTypedArg(t.wiggle.spread,e.NUMBER,0)},this.rotation={_axis:o.ensureInstanceOf(t.rotation.axis,r.Vector3,new r.Vector3(0,1,0)),_axisSpread:o.ensureInstanceOf(t.rotation.axisSpread,r.Vector3,new r.Vector3),_angle:o.ensureTypedArg(t.rotation.angle,e.NUMBER,0),_angleSpread:o.ensureTypedArg(t.rotation.angleSpread,e.NUMBER,0),_static:o.ensureTypedArg(t.rotation.static,e.BOOLEAN,!1),_center:o.ensureInstanceOf(t.rotation.center,r.Vector3,this.position._value.clone()),_randomise:o.ensureTypedArg(t.rotation.randomise,e.BOOLEAN,!1)},this.maxAge={_value:o.ensureTypedArg(t.maxAge.value,e.NUMBER,2),_spread:o.ensureTypedArg(t.maxAge.spread,e.NUMBER,0)},this.color={_value:o.ensureArrayInstanceOf(t.color.value,r.Color3,new r.Color3(1,1,1)),_spread:o.ensureArrayInstanceOf(t.color.spread,r.Vector3,new r.Vector3),_randomise:o.ensureTypedArg(t.color.randomise,e.BOOLEAN,!1)},this.opacity={_value:o.ensureArrayTypedArg(t.opacity.value,e.NUMBER,1),_spread:o.ensureArrayTypedArg(t.opacity.spread,e.NUMBER,0),_randomise:o.ensureTypedArg(t.opacity.randomise,e.BOOLEAN,!1)},this.size={_value:o.ensureArrayTypedArg(t.size.value,e.NUMBER,1),_spread:o.ensureArrayTypedArg(t.size.spread,e.NUMBER,0),_randomise:o.ensureTypedArg(t.size.randomise,e.BOOLEAN,!1)},this.angle={_value:o.ensureArrayTypedArg(t.angle.value,e.NUMBER,0),_spread:o.ensureArrayTypedArg(t.angle.spread,e.NUMBER,0),_randomise:o.ensureTypedArg(t.angle.randomise,e.BOOLEAN,!1)},this.resetFlags={position:o.ensureTypedArg(t.position.randomise,e.BOOLEAN,!1)||o.ensureTypedArg(t.radius.randomise,e.BOOLEAN,!1),velocity:o.ensureTypedArg(t.velocity.randomise,e.BOOLEAN,!1),acceleration:o.ensureTypedArg(t.acceleration.randomise,e.BOOLEAN,!1)||o.ensureTypedArg(t.drag.randomise,e.BOOLEAN,!1),rotation:o.ensureTypedArg(t.rotation.randomise,e.BOOLEAN,!1),size:o.ensureTypedArg(t.size.randomise,e.BOOLEAN,!1),color:o.ensureTypedArg(t.color.randomise,e.BOOLEAN,!1),opacity:o.ensureTypedArg(t.opacity.randomise,e.BOOLEAN,!1),angle:o.ensureTypedArg(t.angle.randomise,e.BOOLEAN,!1)},this.updateFlags={},this.updateCounts={},this.updateMap={maxAge:"params",position:"position",velocity:"velocity",acceleration:"acceleration",drag:"acceleration",wiggle:"params",rotation:"rotation",size:"size",color:"color",opacity:"opacity",angle:"angle"};for(const t in this.updateMap)this.updateMap.hasOwnProperty(t)&&(this.updateCounts[this.updateMap[t]]=0,this.updateFlags[this.updateMap[t]]=!1,this._createGetterSetters(this[t],t));o.ensureValueOverLifetimeCompliance(this.color,i,i),o.ensureValueOverLifetimeCompliance(this.opacity,i,i),o.ensureValueOverLifetimeCompliance(this.size,i,i),o.ensureValueOverLifetimeCompliance(this.angle,i,i),this.particleCount=o.ensureTypedArg(t.particleCount,e.NUMBER,100),this.duration=o.ensureTypedArg(t.duration,e.NUMBER,null),this.isStatic=o.ensureTypedArg(t.isStatic,e.BOOLEAN,!1),this.activeMultiplier=o.ensureTypedArg(t.activeMultiplier,e.NUMBER,1),this.direction=o.ensureTypedArg(t.direction,e.NUMBER,1),this.isLookAtCamera=o.ensureTypedArg(t.isLookAtCamera,e.BOOLEAN,!1),this.isLookAtCameraOnlyY=o.ensureTypedArg(t.isLookAtCameraOnlyY,e.BOOLEAN,!1),this.alive=o.ensureTypedArg(t.alive,e.BOOLEAN,!0),this.particlesPerSecond=0,this.calculatePPSValue(),this.age=0,this.group=null}_createGetterSetters(t,e){const i=this;for(const r in t)if(t.hasOwnProperty(r)){const s=r.replace("_","");Object.defineProperty(t,s,{get:function(t){return function(){return this[t]}}(r),set:function(t){return function(r){const s=i.updateMap[e],n=this[t],l=a.valueOverLifetimeLength;"_randomise"===t?i.resetFlags[s]=r:("_distribution"===t&&i._setDistributeFunctions(s,r),i.updateFlags[s]=!0,i.updateCounts[s]=0),this[t]=r,i.group.$updateDefines(i),Array.isArray(n)&&o.ensureValueOverLifetimeCompliance(i[e],l,l)}}(r)})}}calculatePPSValue(){const t=this.particleCount,e=this.maxAge._value+Math.abs(.5*this.maxAge._spread);return null!==this.duration?this.particlesPerSecond=t/Math.min(e,this.duration):this.particlesPerSecond=t/e,this}enable(){return this.alive=!0,this}disable(){return this.alive=!1,this}remove(){return null!==this.group?this.group.removeEmitter(this):console.error("Emitter does not belong to a group, cannot remove."),this}reset(t){}_assignValue(){}_assignPositionValue(t,e){const i=this.position,r=i._value,a=i._spread,o=i._spreadClamp;return i._getDistributionFunction(t,e,r,a,o,i._radius,i._radiusScale),t}_assignForceValue(t,e,i,r){const a=this[i],s=a._value,n=a._spread;if(a._getDistributionFunction(t,e,s,n,r[0],r[1],r[2],this.position._value),"acceleration"===i){const i=o.clamp(o.randomFloat(this.drag._value,this.drag._spread),0,1);t[e+3]=i}return t}_assignAbsLifetimeValue(t,e,i){const r=this[i];if(o.arrayValuesAreEqual(r._value)&&o.arrayValuesAreEqual(r._spread)){const i=Math.abs(o.randomFloat(r._value[0],r._spread[0]));t[e+0]=i,t[e+1]=i,t[e+2]=i,t[e+3]=i}else t[e+0]=Math.abs(o.randomFloat(r._value[0],r._spread[0])),t[e+1]=Math.abs(o.randomFloat(r._value[1],r._spread[1])),t[e+2]=Math.abs(o.randomFloat(r._value[2],r._spread[2])),t[e+3]=Math.abs(o.randomFloat(r._value[3],r._spread[3]));return t}_assignAngleValue(t,e){const i=this.angle;if(o.arrayValuesAreEqual(i._value)&&o.arrayValuesAreEqual(i._spread)){const r=o.randomFloat(i._value[0],i._spread[0]);t[e+0]=r,t[e+1]=r,t[e+2]=r,t[e+3]=r}else t[e+0]=o.randomFloat(i._value[0],i._spread[0]),t[e+1]=o.randomFloat(i._value[1],i._spread[1]),t[e+2]=o.randomFloat(i._value[2],i._spread[2]),t[e+3]=o.randomFloat(i._value[3],i._spread[3]);return t}_assignParamsValue(t,e,i){return t[e+0]=i?this.isStatic?1:0:1,t[e+1]=0,t[e+2]=o.randomFloat(this.maxAge._value,this.maxAge._spread),t[e+3]=o.randomFloat(this.wiggle._value,this.wiggle._spread),t}_assignRotationValue(t,e,i,r,a){const s=o.getRotationAxis(u,this.rotation._axis,this.rotation._axisSpread);a?(s.x+=1,s.y+=1,s.z+=1,s.multiplyScalar(.5),c.setRGB(s.x,s.y,s.z),t[e+0]=c.getHex(),t[e+1]=o.randomFloat(this.rotation._angle,this.rotation._angleSpread),t[e+2]=this.rotation._static?0:1):(t[e+0]=s.x,t[e+1]=s.y,t[e+2]=s.z,t[e+3]=o.randomFloat(this.rotation._angle,this.rotation._angleSpread),t[e+4]=this.rotation._static?0:1),this.rotation._center.toArray(i,r)}_assignColorValue(t,e,i){const r=this.color._value,a=this.color._spread,s=r.length;for(let n=0;n<s;++n){const s=a[n];c.copy(r[n]),c.r+=Math.random()*s.x-.5*s.x,c.g+=Math.random()*s.y-.5*s.y,c.b+=Math.random()*s.z-.5*s.z,c.r=o.clamp(c.r,0,1),c.g=o.clamp(c.g,0,1),c.b=o.clamp(c.b,0,1),i?t[e+n]=c.getHex():c.toArray(t,e+3*n)}}_setDistributeFunctions(t,e){this[t]._getDistributionFunction="function"==typeof e?e:h[t][e]}}const u=new r.Vector3,c=new r.Color3,h={position:{1:o.getRandomVector3,2:o.getRandomVector3OnSphere,3:o.getRandomVector3OnDisc,4:o.getRandomVector3OnLine},velocity:{1:o.getRandomVector3,2:o.getRandomDirectionVector3OnSphere,3:o.getRandomDirectionVector3OnDisc,4:o.getRandomVector3OnLine},acceleration:{1:o.getRandomVector3,2:o.getRandomDirectionVector3OnSphere,3:o.getRandomDirectionVector3OnDisc,4:o.getRandomVector3OnLine}};class f extends l{constructor(t){super(t),this.activationIndex=0,this.attributeOffset=0,this.attributeEnd=0,this.activeParticleCount=0,this.attributes=null,this.bufferUpdateRanges={},this.attributeKeys=null,this.attributeCount=0}tick(t){if(this.isStatic)return;const e=this.attributeOffset,i=e+this.particleCount,r=this.attributes.params.buffer.array,a=this.particlesPerSecond*this.activeMultiplier*t,o=this.activationIndex;if(this._resetBufferRanges(),this._checkParticleAges(e,i,r,t),!1===this.alive)return void(this.age=0);if(null!==this.duration&&this.age>this.duration)return this.alive=!1,void(this.age=0);const s=1===this.particleCount?o:0|o,n=Math.min(s+a,this.activationEnd),l=n-this.activationIndex|0,u=l>0?t/l:0;this._activateParticles(s,n,r,u),this.activationIndex+=a,this.activationIndex>i&&(this.activationIndex=e),this.age+=t}reset(t){if(this.age=0,this.alive=!1,!0===t){const t=this.attributeOffset,e=t+this.particleCount,i=this.attributes.params.buffer.array,r=this.attributes.params;for(let r,a=e-1;a>=t;--a)r=4*a,i[r]=0,i[r+1]=0;r.updateRange.offset=0,r.updateRange.count=-1,r.needsUpdate=!0}return this}_assignValue(t,e){let i,r,a,o,s;switch(t){case"position":i=this.attributes.position.buffer.array,this._assignPositionValue(i,this.attributes.position.size*e);break;case"velocity":case"acceleration":i=this.attributes.position.buffer.array,a=i[3*e+0],o=i[3*e+1],s=i[3*e+2],i=this.attributes[t].buffer.array,this._assignForceValue(i,this.attributes[t].size*e,t,[a,o,s]);break;case"size":case"opacity":i=this.attributes[t].buffer.array,this._assignAbsLifetimeValue(i,this.attributes[t].size*e,t);break;case"angle":i=this.attributes.angle.buffer.array,this._assignAngleValue(i,this.attributes.angle.size*e);break;case"params":i=this.attributes.params.buffer.array,this._assignParamsValue(i,this.attributes.params.size*e,!0);break;case"rotation":i=this.attributes.rotation.buffer.array,r=this.attributes.rotationCenter.buffer.array,this._assignRotationValue(i,this.attributes.rotation.size*e,r,this.attributes.rotationCenter.size*e,!0);break;case"color":i=this.attributes.color.buffer.array,this._assignColorValue(i,this.attributes.color.size*e,!0)}}_resetParticle(t){const e=this.resetFlags,i=this.updateFlags,r=this.updateCounts,a=this.attributeKeys;let o,s;for(let n=this.attributeCount-1;n>=0;--n)o=a[n],s=i[o],!0!==e[o]&&!0!==s||(this._assignValue(o,t),this._updateAttributeUpdateRange(o,t),!0===s&&r[o]===this.particleCount?(i[o]=!1,r[o]=0):1==s&&++r[o])}_setBufferUpdateRanges(t){this.attributeKeys=t,this.attributeCount=t.length;for(let e=this.attributeCount-1;e>=0;--e)this.bufferUpdateRanges[t[e]]={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY}}_setAttributeOffset(t){this.attributeOffset=t,this.activationIndex=t,this.activationEnd=t+this.particleCount}_updateAttributeUpdateRange(t,e){const i=this.bufferUpdateRanges[t];i.min=Math.min(e,i.min),i.max=Math.max(e,i.max)}_resetBufferRanges(){const t=this.bufferUpdateRanges,e=this.bufferUpdateKeys;let i,r=this.bufferUpdateCount-1;for(;r>=0;--r)i=e[r],t[i].min=Number.POSITIVE_INFINITY,t[i].max=Number.NEGATIVE_INFINITY}_onRemove(){this.particlesPerSecond=0,this.attributeOffset=0,this.activationIndex=0,this.activeParticleCount=0,this.group=null,this.attributes=null,this.age=0}_decrementParticleCount(){--this.activeParticleCount}_incrementParticleCount(){++this.activeParticleCount}_checkParticleAges(t,e,i,r){for(let a,o,s,n,l=e-1;l>=t;--l)a=4*l,n=i[a],0!==n&&(s=i[a+1],o=i[a+2],1===this.direction?(s+=r,s>=o&&(s=0,n=0,this._decrementParticleCount())):(s-=r,s<=0&&(s=o,n=0,this._decrementParticleCount())),i[a]=n,i[a+1]=s,this._updateAttributeUpdateRange("params",l))}_activateParticles(t,e,i,r){const a=this.direction;for(let o,s,n=t;n<e;++n)o=4*n,0!=i[o]&&1!==this.particleCount||(this._incrementParticleCount(),i[o]=1,this._resetParticle(n),s=r*(n-t),i[o+1]=-1===a?i[o+2]-s:s,this._updateAttributeUpdateRange("params",n))}}class p{constructor(t){this.uuid=r.generateUUID();const e=o.types;t.texture=o.ensureTypedArg(t.texture,e.OBJECT,{}),this.fixedTimeStep=o.ensureTypedArg(t.fixedTimeStep,e.NUMBER,.016),this.hasPerspective=o.ensureTypedArg(t.hasPerspective,e.BOOLEAN,!0),this.colorize=o.ensureTypedArg(t.colorize,e.BOOLEAN,!0),this._emitters=[]}addEmitter(t){}removeEmitter(t){}tick(t){}dispose(){}_setMaterial(t,e){const i=o.types;t.uniforms.tex=o.ensureInstanceOf(e.texture.value,r.Texture2D,d),t.blending=o.ensureTypedArg(e.blending,i.STRING,r.BLEND_TYPE.ADD),t.transparent=o.ensureTypedArg(e.transparent,i.BOOLEAN,!0),t.alphaTest=o.ensureTypedArg(e.alphaTest,i.NUMBER,0),t.depthWrite=o.ensureTypedArg(e.depthWrite,i.BOOLEAN,!1),t.depthTest=o.ensureTypedArg(e.depthTest,i.BOOLEAN,!0),t.fog=o.ensureTypedArg(e.fog,i.BOOLEAN,!0)}}const d=new r.Texture2D;d.image={data:new Uint8Array([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255]),width:2,height:2},d.magFilter=r.TEXTURE_FILTER.NEAREST,d.minFilter=r.TEXTURE_FILTER.NEAREST,d.generateMipmaps=!1;const g={position:3,acceleration:4,velocity:3,rotation:4,rotationCenter:3,params:4,size:4,angle:4,color:4,opacity:4};const m={name:"mesh_particle_shader",uniforms:{tex:null},vertexShader:"\n\t\t#include <common_vert>\n\n\t\tattribute vec3 mcol0;\n\t\tattribute vec3 mcol1;\n\t\tattribute vec3 mcol2;\n\t\tattribute vec3 mcol3;\n\t\tattribute vec4 color;\n\n\t\tattribute vec2 a_Uv;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 varyColor;\n\n\t\t#include <logdepthbuf_pars_vert>\n\n\t\tvoid main() {\n\t\t\tmat4 matrix = mat4(\n\t\t\t\tvec4(mcol0, 0),\n\t\t\t\tvec4(mcol1, 0),\n\t\t\t\tvec4(mcol2, 0),\n\t\t\t\tvec4(mcol3, 1)\n\t\t\t);\n\n\t\t\tvec4 worldPosition = u_Model * matrix * vec4(a_Position, 1.0);\n\t\t\tgl_Position = u_ProjectionView * worldPosition;\n\n\t\t\tvaryColor = color;\n\t\t\tvUv = a_Uv;\n\n\t\t\t#include <logdepthbuf_vert>\n\t\t}\n\t",fragmentShader:"\n\t\tuniform sampler2D tex;\n\n\t\t#include <common_frag>\n\t\t#include <fog_pars_frag>\n\t\t#include <logdepthbuf_pars_frag>\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 varyColor;\n\n\t\tvoid main() {\n\t\t\t#include <logdepthbuf_frag>\n\n\t\t\tgl_FragColor = varyColor * texture2D(tex, vUv);\n\n\t\t\t#include <fog_frag>\n\t\t}\n\t"};class _{constructor(){this._matrix=new r.Matrix4,this._color=new r.Color3(1,1,1),this._opacity=1,this._originPosition=[0,0,0],this._originVelocity=[0,0,0],this._originAcceleration=[0,0,0,0],this._originOpacityArray=[],this._originSizeArray=[],this._originAngleArray=[],this._originColorArray=[1,1,1,1,1,1,1,1,1,1,1,1],this._originParams=[0,0,0,0],this._originRotation=[0,1,0,0,0],this._originRotationCenter=[0,0,0]}isAlive(){return!!this._originParams[0]}tick(t,e,i){this._originParams[1]+=t,this._originParams[1]>this._originParams[2]&&(this._originParams[0]=0),0!==this._originParams[0]?this._update(e,i):this._originParams[1]=0}submit(t,e){const i=16*e,r=this._matrix.elements;t[i]=r[0],t[i+1]=r[1],t[i+2]=r[2],t[i+3]=r[4],t[i+4]=r[5],t[i+5]=r[6],t[i+6]=r[8],t[i+7]=r[9],t[i+8]=r[10],t[i+9]=r[12],t[i+10]=r[13],t[i+11]=r[14],t[i+12]=this._color.r,t[i+13]=this._color.g,t[i+14]=this._color.b,t[i+15]=this._opacity}_update(t,e){const i=this._originParams[1],r=i/this._originParams[2],s=y.fromArray(this._originAcceleration);if(e.SHOULD_DRAG_PARTICLES){const t=1-.5*r*this._originAcceleration[3];s.multiplyScalar(t)}E.fromArray(this._originVelocity).multiplyScalar(i);const n=s.multiplyScalar(i*i*.5);if(E.add(v.fromArray(this._originPosition)).add(n),e.SHOULD_WIGGLE_PARTICLES){const t=r*this._originParams[3]*Math.PI,e=Math.sin(t),i=Math.cos(t);E.x+=e,E.y+=i,E.z+=e}if(e.SHOULD_ROTATE_PARTICLES){const t=this._originRotation[3];if(0!==t){let e=0;e=0===this._originRotation[4]?t:o.lerp(0,t,r);const i=y.fromArray(this._originRotation),a=x.makeRotationAxis(i,e),s=y.fromArray(this._originRotationCenter).sub(E);s.applyMatrix4(a),E.fromArray(this._originRotationCenter).sub(s)}}if(b.set(1,1,1),e.SHOULD_SIZE_PARTICLES){const t=C(r,this._originSizeArray);b.set(t,t,t)}if(e.isLookAtCamera||e.isLookAtCameraOnlyY)e.isLookAtCamera?O.copy(t.quaternion):e.isLookAtCameraOnlyY&&(x.getInverse(e.group.mesh.worldMatrix),x.multiply(t.worldMatrix),y.setFromMatrixPosition(x),v.copy(E).sub(y),v.y=0,O.setFromUnitVectors(y.set(0,0,-1),v.normalize()));else if(e.SHOULD_ANGLE_PARTICLES){const t=C(r,this._originAngleArray);A.set(t,t,t),O.setFromEuler(A,!1)}this._matrix.transform(E,b,O),e.SHOULD_COLORIZE_PARTICLES?(!function(t,e,i){const r=a.valueOverLifetimeLength-1;if(t<=0)i.fromArray(e,0);else if(t>=1)i.fromArray(e,3*r);else{const a=t*r;let o,s,n;for(let t=0;t<r;t++)if(a>t&&a<t+1){o=a-t,s=3*t,n=s+3,i.r=o*(e[n+0]-e[s+0])+e[s+0],i.g=o*(e[n+1]-e[s+1])+e[s+1],i.b=o*(e[n+2]-e[s+2])+e[s+2];break}}}(r,this._originColorArray,this._color),this._opacity=C(r,this._originOpacityArray)):(this._color.setRGB(1,1,1),this._opacity=1)}}const y=new r.Vector3,v=new r.Vector3,A=new r.Euler,x=new r.Matrix4,E=new r.Vector3,O=new r.Quaternion,b=new r.Vector3;function C(t,e){const i=a.valueOverLifetimeLength-1;let r=0;if(t<=0)r=0;else if(t>=1)r=e[i];else{const a=t*i;for(let t=0;t<i;t++)if(a>t&&a<t+1){r+=o.lerp(e[t],e[t+1],a-t);break}}return r}class T extends l{constructor(t){super(t),this._activeParticles=new Array,this._particlePool=new Array}tick(t,e){if(this.isStatic){for(let t=0,e=this._activeParticles.length;t<e;t++)if(this._activeParticles[t].isAlive()){const e=this.group;this._activeParticles[t].submit(e.$instanceBuffer.array,e.$allocBufferIndex())}return}if(!1===this.alive)return void(this.age=0);const i=null!==this.duration&&this.age>this.duration;if(!i){const e=this._activeParticles.length,i=this.particlesPerSecond*this.activeMultiplier*t,r=Math.min(e+i,this.particleCount)-e;for(let t=0;t<r;t++){const t=this._particlePool.length<=0?new _:this._particlePool.shift();this._resetParticle(t),this._activeParticles.push(t)}}for(let i=0,r=this._activeParticles.length;i<r;i++)if(this._activeParticles[i].tick(t,e,this),this._activeParticles[i].isAlive()){const t=this.group;this._activeParticles[i].submit(t.$instanceBuffer.array,t.$allocBufferIndex())}else this._particlePool.push(this._activeParticles[i]),this._activeParticles.splice(i,1),r--,i--;i&&this._activeParticles.length<=0&&(this.alive=!1,this.age=0),this.alive&&(this.age+=t)}reset(t){this.alive=!1,this.age=0,t&&(this._activeParticles=[],this._particlePool=[])}$updateFlags(t){this.SHOULD_DRAG_PARTICLES=!!Math.max(this.drag._value,this.drag._spread),this.SHOULD_WIGGLE_PARTICLES=!!Math.max(this.wiggle._value,this.wiggle._spread),this.SHOULD_ROTATE_PARTICLES=!!Math.max(this.rotation._angle,this.rotation._angleSpread),this.SHOULD_COLORIZE_PARTICLES=t.colorize,this.SHOULD_SIZE_PARTICLES=!0,this.SHOULD_ANGLE_PARTICLES=!0}_assignValue(t,e,i,r){switch(t){case"position":this._assignPositionValue(e,0);break;case"velocity":case"acceleration":this._assignForceValue(e,0,t,i);break;case"size":case"opacity":this._assignAbsLifetimeValue(e,0,t);break;case"angle":this._assignAngleValue(e,0);break;case"params":this._assignParamsValue(e,0);break;case"rotation":this._assignRotationValue(e,0,r,0);break;case"color":this._assignColorValue(e,0)}}_resetParticle(t){this._assignValue("position",t._originPosition),this._assignValue("velocity",t._originVelocity,t._originPosition),this._assignValue("acceleration",t._originAcceleration,t._originPosition),this._assignValue("opacity",t._originOpacityArray),this._assignValue("size",t._originSizeArray),this._assignValue("angle",t._originAngleArray),this._assignValue("color",t._originColorArray),this._assignValue("params",t._originParams),this._assignValue("rotation",t._originRotation,void 0,t._originRotationCenter)}}t.MeshParticleEmitter=T,t.MeshParticleGroup=class extends p{constructor(t){const e=o.types;super(t=o.ensureTypedArg(t,e.OBJECT,{})),void 0===t.maxParticleCount&&(console.warn("MeshParticleGroup: options.maxParticleCount is not provided, set to 1000 by default."),t.maxParticleCount=1e3),this.maxParticleCount=t.maxParticleCount,t.geometry&&t.geometry instanceof r.Geometry||(console.warn("MeshParticleGroup: options.geometry is not provided, set a box geometry by default."),t.geometry=new r.BoxGeometry(1,1,1));const i=function(t,e){const i=t.clone(),a=new r.Buffer(new Float32Array(16*e),16);a.usage=r.BUFFER_USAGE.DYNAMIC_DRAW;const o=new r.Attribute(a,3,0),s=new r.Attribute(a,3,3),n=new r.Attribute(a,3,6),l=new r.Attribute(a,3,9),u=new r.Attribute(a,4,12);return o.divisor=1,s.divisor=1,n.divisor=1,l.divisor=1,u.divisor=1,i.addAttribute("mcol0",o),i.addAttribute("mcol1",s),i.addAttribute("mcol2",n),i.addAttribute("mcol3",l),i.addAttribute("color",u),i}(t.geometry,this.maxParticleCount),a=new r.ShaderMaterial(m);this._setMaterial(a,t),this.mesh=new r.Mesh(i,a),this.mesh.frustumCulled=!1,this.$instanceBuffer=i.attributes.mcol0.buffer,this._geometry=i,this._particleCount=0,this._aliveParticleCount=0}addEmitter(t){if(t instanceof T!=!1)if(this._emitters.indexOf(t)>-1)console.error("MeshParticleEmitter already exists in this group. Will not add again.");else{if(null===t.group)return this._particleCount+=t.particleCount,this._particleCount>this.maxParticleCount&&console.warn("MeshParticleGroup: maxParticleCount exceeded. Requesting",this._particleCount,"particles, can support only",this.maxParticleCount),t.group=this,this._emitters.push(t),this.$updateDefines(t),this;console.error("MeshParticleEmitter already belongs to another group. Will not add to requested group.")}else console.error("`emitter` argument must be instance of MeshParticleEmitter. Was provided with:",t)}removeEmitter(t){const e=this._emitters.indexOf(t);if(t instanceof T!=!1){if(-1!==e)return this._particleCount-=t.particleCount,t.group=null,this._emitters.splice(e,1),this;console.error("MeshParticleEmitter does not exist in this group. Will not remove.")}else console.error("`emitter` argument must be instance of MeshParticleEmitter. Was provided with:",t)}tick(t,e){const i=this._emitters,r=i.length,a=t||this.fixedTimeStep;if(0!==r){this._aliveParticleCount=0;for(let t=0;t<r;t++)i[t].tick(a,e);this.$instanceBuffer.version++,this._geometry.instanceCount=this._aliveParticleCount}}dispose(){this.mesh.geometry.dispose(),this.mesh.material.dispose();for(let t=0,e=this._emitters.length;t<e;t++)this._emitters[t].group=null;return this._emitters=[],this._particleCount=0,this._aliveParticleCount=0,this}get particleCount(){return this._particleCount}get aliveParticleCount(){return this._aliveParticleCount}$updateDefines(t){t.$updateFlags(this)}$allocBufferIndex(){return this._aliveParticleCount++}},t.ParticleEmitter=f,t.ParticleGroup=class extends p{constructor(t){const e=o,i=e.types;super(t=o.ensureTypedArg(t,i.OBJECT,{})),this.maxParticleCount=e.ensureTypedArg(t.maxParticleCount,i.NUMBER,null),null===this.maxParticleCount&&console.warn("ParticleGroup: No maxParticleCount specified. Adding emitters after rendering will probably cause errors."),this.textureFrames=o.ensureInstanceOf(t.texture.frames,r.Vector2,new r.Vector2(1,1)),this.textureFrames.max(new r.Vector2(1,1)),this.textureFrameCount=o.ensureTypedArg(t.texture.frameCount,i.NUMBER,this.textureFrames.x*this.textureFrames.y),this.textureLoop=o.ensureTypedArg(t.texture.loop,i.NUMBER,1),this.material=new r.ShaderMaterial({defines:{HAS_PERSPECTIVE:this.hasPerspective,COLORIZE:this.colorize,VALUE_OVER_LIFETIME_LENGTH:a.valueOverLifetimeLength,SHOULD_ROTATE_TEXTURE:!1,SHOULD_ROTATE_PARTICLES:!1,SHOULD_WIGGLE_PARTICLES:!1,SHOULD_CALCULATE_SPRITE:this.textureFrames.x>1||this.textureFrames.y>1},uniforms:{tex:null,textureAnimation:[this.textureFrames.x,this.textureFrames.y,this.textureFrameCount,Math.max(Math.abs(this.textureLoop),1)],scale:e.ensureTypedArg(t.scale,i.NUMBER,300),deltaTime:0,runTime:0},vertexShader:n.vertex,fragmentShader:n.fragment}),this._setMaterial(this.material,t),this.material.drawMode=r.DRAW_MODE.POINTS,this.uniforms=this.material.uniforms,this.defines=this.material.defines,this.geometry=new r.Geometry,this.geometry.addGroup(0,this.particleCount,0),this.mesh=new r.Mesh(this.geometry,[this.material]),this.mesh.frustumCulled=!1,this.attributes={position:null,acceleration:null,velocity:null,rotation:null,rotationCenter:null,params:null,size:null,angle:null,color:null,opacity:null},this.attributeKeys=Object.keys(this.attributes),this.attributeCount=this.attributeKeys.length,this._attributesNeedRefresh=!1,this._attributesNeedDynamicReset=!1,this.particleCount=0}addEmitter(t){if(t instanceof f==!1)return void console.error("`emitter` argument must be instance of ParticleEmitter. Was provided with:",t);if(this._emitters.indexOf(t)>-1)return void console.error("ParticleEmitter already exists in this group. Will not add again.");if(null!==t.group)return void console.error("ParticleEmitter already belongs to another group. Will not add to requested group.");const e=this.attributes,i=this.particleCount,a=i+t.particleCount;this.particleCount=a,null!==this.maxParticleCount&&this.particleCount>this.maxParticleCount&&console.warn("ParticleGroup: maxParticleCount exceeded. Requesting",this.particleCount,"particles, can support only",this.maxParticleCount),t._setBufferUpdateRanges(this.attributeKeys),t._setAttributeOffset(i),t.group=this,t.attributes=this.attributes;for(const t in e)if(e.hasOwnProperty(t)){const i=e[t],a=null!==this.maxParticleCount?this.maxParticleCount:this.particleCount;if(null!==i&&null!==i.buffer.array){if(i.buffer.array.length!==a*i.size){const t=i.buffer.array.length,e=a*i.size;if(e<t)i.buffer.array=i.buffer.array.subarray(0,e);else{const t=i.buffer.array,r=new Float32Array(e);r.set(t),i.buffer.array=r}i.buffer.count=a,i.buffer.version++}}else e[t]=new r.Attribute(new r.Buffer(new Float32Array(a*g[t]),g[t])),e[t].buffer.usage=r.BUFFER_USAGE.DYNAMIC_DRAW}for(let e=i;e<a;++e)t._assignValue("position",e),t._assignValue("velocity",e),t._assignValue("acceleration",e),t._assignValue("size",e),t._assignValue("opacity",e),t._assignValue("angle",e),t._assignValue("params",e),t._assignValue("rotation",e),t._assignValue("color",e);return this._applyAttributesToGeometry(),this._emitters.push(t),this.$updateDefines(t),this._attributesNeedRefresh=!0,this}removeEmitter(t){const e=this._emitters.indexOf(t);if(t instanceof f==!1)return void console.error("`emitter` argument must be instance of ParticleEmitter. Was provided with:",t);if(-1===e)return void console.error("ParticleEmitter does not exist in this group. Will not remove.");const i=t.attributeOffset,r=i+t.particleCount,a=this.attributes.params.buffer.array;for(let t=i;t<r;++t)a[4*t]=0,a[4*t+1]=0;this._emitters.splice(e,1);for(const t in this.attributes)if(this.attributes.hasOwnProperty(t)){const e=this.attributes[t],a=i*e.size,o=r*e.size;let s=e.buffer.array;const n=[];for(let t=0;t<s.length;++t)(t<a||t>=o)&&n.push(s[t]);s=s.subarray(0,n.length),s.set(n),this.attributes[t].buffer.array=s}for(let i=this._emitters.length-1;i>=e;i--){const e=this._emitters[i].attributeOffset-t.particleCount;this._emitters[i]._setAttributeOffset(e)}this.particleCount-=t.particleCount,this.geometry.groups[0].count=this.particleCount,t._onRemove(),this._attributesNeedRefresh=!0}tick(t){const e=this._emitters,i=e.length,a=t||this.fixedTimeStep,o=this.attributeKeys,s=this.attributes;let n,l;if(this.uniforms.runTime+=a,this.uniforms.deltaTime=a,0!==i||!1!==this._attributesNeedRefresh||!1!==this._attributesNeedDynamicReset){for(l=0;l<i;++l)e[l].tick(a);for(n=this.attributeCount-1;n>=0;--n){const t=o[n];let r=1/0,a=-1/0;for(l=0;l<i;++l){const i=e[l].bufferUpdateRanges[t];r=Math.min(i.min,r),a=Math.max(i.max,a)}if(a-r>0){const e=s[t];e.buffer.updateRange.offset=r*e.size,e.buffer.updateRange.count=Math.min((a-r+1)*e.size,e.buffer.array.length),e.buffer.version++}}if(!0===this._attributesNeedDynamicReset){for(n=this.attributeCount-1;n>=0;--n)s[o[n]].buffer.usage=r.BUFFER_USAGE.DYNAMIC_DRAW;this._attributesNeedDynamicReset=!1}if(!0===this._attributesNeedRefresh){for(n=this.attributeCount-1;n>=0;--n)s[o[n]].buffer.updateRange.offset=0,s[o[n]].buffer.updateRange.count=-1,s[o[n]].buffer.usage=r.BUFFER_USAGE.STATIC_DRAW,s[o[n]].buffer.version++;this._attributesNeedRefresh=!1,this._attributesNeedDynamicReset=!0}}}dispose(){return this.mesh.geometry.dispose(),this.mesh.material[0].dispose(),this}$updateDefines(){const t=this._emitters,e=this.defines;let i,r=t.length-1;for(;r>=0;--r)i=t[r],e.SHOULD_ROTATE_TEXTURE=e.SHOULD_ROTATE_TEXTURE||o.hasNonZeroElement(i.angle.value)||o.hasNonZeroElement(i.angle.spread),e.SHOULD_ROTATE_PARTICLES=e.SHOULD_ROTATE_PARTICLES||0!==i.rotation.angle||0!==i.rotation.angleSpread,e.SHOULD_WIGGLE_PARTICLES=e.SHOULD_WIGGLE_PARTICLES||0!==i.wiggle.value||0!==i.wiggle.spread;this.material.needsUpdate=!0}_applyAttributesToGeometry(){const t=this.attributes,e=this.geometry,i=e.attributes;let r,a;for(const o in t)t.hasOwnProperty(o)&&(r=t[o],a=i["position"===o?"a_Position":o],a||e.addAttribute("position"===o?"a_Position":o,r));this.geometry.version++,this.geometry.groups[0].count=this.particleCount}},t.ParticleProperties=a}));
