// t3d-particle
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("t3d")):"function"==typeof define&&define.amd?define(["exports","t3d"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).t3d=t.t3d||{},t.t3d)}(this,(function(t,e){"use strict";function i(t){var e=Object.create(null);return t&&Object.keys(t).forEach((function(i){if("default"!==i){var r=Object.getOwnPropertyDescriptor(t,i);Object.defineProperty(e,i,r.get?r:{enumerable:!0,get:function(){return t[i]}})}})),e.default=t,Object.freeze(e)}var r=i(e);const n={distributions:{BOX:1,SPHERE:2,DISC:3,LINE:4},valueOverLifetimeLength:4},a={types:{BOOLEAN:"boolean",STRING:"string",NUMBER:"number",OBJECT:"object"},ensureTypedArg:function(t,e,i){return typeof t===e?t:i},ensureArrayTypedArg:function(t,e,i){if(Array.isArray(t)){for(let r=t.length-1;r>=0;--r)if(typeof t[r]!==e)return i;return t}return this.ensureTypedArg(t,e,i)},ensureInstanceOf:function(t,e,i){return void 0!==e&&t instanceof e?t:i},ensureArrayInstanceOf:function(t,e,i){if(Array.isArray(t)){for(let r=t.length-1;r>=0;--r)if(void 0!==e&&t[r]instanceof e==!1)return i;return t}return this.ensureInstanceOf(t,e,i)},ensureValueOverLifetimeCompliance:function(t,e,i){e=e||3,i=i||3,!1===Array.isArray(t._value)&&(t._value=[t._value]),!1===Array.isArray(t._spread)&&(t._spread=[t._spread]);const r=this.clamp(t._value.length,e,i),n=this.clamp(t._spread.length,e,i),a=Math.max(r,n);t._value.length!==a&&(t._value=this.interpolateArray(t._value,a)),t._spread.length!==a&&(t._spread=this.interpolateArray(t._spread,a))},interpolateArray:function(t,e){const i=t.length,r=["function"==typeof t[0].clone?t[0].clone():t[0]],n=(i-1)/(e-1);for(let i=1;i<e-1;i++){const e=i*n,a=Math.floor(e),o=Math.ceil(e),s=e-a;r[i]=this.lerpTypeAgnostic(t[a],t[o],s)}return r.push("function"==typeof t[i-1].clone?t[i-1].clone():t[i-1]),r},clamp:function(t,e,i){return Math.max(e,Math.min(t,i))},zeroToEpsilon:function(t,e){const i=1e-5;let r=t;return r=e?Math.random()*i*10:i,t<0&&t>-1e-5&&(r=-r),r},lerpTypeAgnostic:function(t,e,i){const n=this.types;let a;return typeof t===n.NUMBER&&typeof e===n.NUMBER?this.lerp(t,e,i):t instanceof r.Vector2&&e instanceof r.Vector2||typeof t.x==n.NUMBER&&typeof t.y==n.NUMBER&&null==t.z&&null==t.z&&typeof e.x==n.NUMBER&&typeof e.y==n.NUMBER&&null==e.z&&null==e.z?(a=t instanceof r.Vector2?new r.Vector2:{},a.x=this.lerp(t.x,e.x,i),a.y=this.lerp(t.y,e.y,i),a):t instanceof r.Vector3&&e instanceof r.Vector3||typeof t.x==n.NUMBER&&typeof t.y==n.NUMBER&&typeof t.z==n.NUMBER&&null==t.w&&null==t.w&&typeof e.x==n.NUMBER&&typeof e.y==n.NUMBER&&typeof e.z==n.NUMBER&&null==e.w&&null==e.w?(a=t instanceof r.Vector3?new r.Vector3:{},a.x=this.lerp(t.x,e.x,i),a.y=this.lerp(t.y,e.y,i),a.z=this.lerp(t.z,e.z,i),a):t instanceof r.Vector4&&e instanceof r.Vector4||typeof t.x==n.NUMBER&&typeof t.y==n.NUMBER&&typeof t.z==n.NUMBER&&typeof t.w==n.NUMBER&&typeof e.x==n.NUMBER&&typeof e.y==n.NUMBER&&typeof e.z==n.NUMBER&&typeof e.w==n.NUMBER?(a=t instanceof r.Vector4?new r.Vector4:{},a.x=this.lerp(t.x,e.x,i),a.y=this.lerp(t.y,e.y,i),a.z=this.lerp(t.z,e.z,i),a.w=this.lerp(t.w,e.w,i),a):t instanceof r.Color3&&e instanceof r.Color3||typeof t.r==n.NUMBER&&typeof t.g==n.NUMBER&&typeof t.b==n.NUMBER&&typeof e.r==n.NUMBER&&typeof e.g==n.NUMBER&&typeof e.b==n.NUMBER?(a=t instanceof r.Color3?new r.Color3:{},a.r=this.lerp(t.r,e.r,i),a.g=this.lerp(t.g,e.g,i),a.b=this.lerp(t.b,e.b,i),a):void console.warn("Invalid argument types, or argument types do not match:",t,e)},lerp:function(t,e,i){return t+(e-t)*i},hasNonZeroElement:function(t){return t.some((t=>0!==t))},roundToNearestMultiple:function(t,e){let i=0;return 0===e?t:(i=Math.abs(t)%e,0===i?t:t<0?-(Math.abs(t)-i):t+e-i)},arrayValuesAreEqual:function(t){for(let e=0;e<t.length-1;++e)if(t[e]!==t[e+1])return!1;return!0},randomFloat:function(t,e){return t+e*(Math.random()-.5)},getRandomVector3:function(t,e,i,r,n){let o=i.x+(Math.random()*r.x-.5*r.x),s=i.y+(Math.random()*r.y-.5*r.y),l=i.z+(Math.random()*r.z-.5*r.z);return n&&n.x&&(o=.5*-n.x+a.roundToNearestMultiple(o,n.x),s=.5*-n.y+a.roundToNearestMultiple(s,n.y),l=.5*-n.z+a.roundToNearestMultiple(l,n.z)),t[e+0]=o,t[e+1]=s,t[e+2]=l,t},getRandomVector3OnSphere:function(t,e,i,r,n,o,s){const l=2*Math.random()-1,u=6.2832*Math.random(),c=Math.sqrt(1-l*l);let h=a.randomFloat(o,r.x),p=0,d=0,f=0;return n.x&&(h=Math.round(h/n.x)*n.x),p=c*Math.cos(u)*h,d=c*Math.sin(u)*h,f=l*h,p*=s.x,d*=s.y,f*=s.z,p+=i.x,d+=i.y,f+=i.z,t[e+0]=p,t[e+1]=d,t[e+2]=f,t},getRandomVector3OnDisc:function(t,e,i,r,n,o,s){const l=6.2832*Math.random();let u=Math.abs(a.randomFloat(o,r.x)),c=0,h=0,p=0;return n.x&&(u=Math.round(u/n.x)*n.x),c=Math.cos(l)*u,h=Math.sin(l)*u,c*=s.x,h*=s.y,c+=i.x,h+=i.y,p+=i.z,t[e+0]=c,t[e+1]=h,t[e+2]=p,t},getRandomVector3OnLine:function(){const t=new r.Vector3;return function(e,i,r,n){return t.lerpVectors(r,n,Math.random()),t.toArray(e,i),e}}(),getRandomDirectionVector3OnSphere:function(){const t=new r.Vector3;return function(e,i,r,n,o,s,l,u){return t.copy(u),t.x-=o,t.y-=s,t.z-=l,t.normalize().multiplyScalar(-a.randomFloat(r.x,n.x)),t.toArray(e,i),e}}(),getRandomDirectionVector3OnDisc:function(){const t=new r.Vector3;return function(e,i,r,n,o,s,l,u){return t.copy(u),t.x-=o,t.y-=s,t.z-=l,t.normalize().multiplyScalar(-a.randomFloat(r.x,n.x)),t.toArray(e,i),e[i+2]=0,e}}(),getRotationAxis:function(){const t=new r.Vector3;return function(e,i,r){return e.copy(i).normalize(),t.copy(r).normalize(),e.x+=.5*-r.x+Math.random()*r.x,e.y+=.5*-r.y+Math.random()*r.y,e.z+=.5*-r.z+Math.random()*r.z,e.normalize(),e}}()},o="\n\t\tuniform float deltaTime;\n\t\tuniform float runTime;\n\t\tuniform sampler2D tex;\n\t\tuniform vec4 textureAnimation;\n\t\tuniform float scale;\n\t",s="\n\t\tvarying vec4 vColor;\n\n\t\t#ifdef SHOULD_ROTATE_TEXTURE\n\t\t\tvarying float vAngle;\n\t\t#endif\n\n\t\t#ifdef SHOULD_CALCULATE_SPRITE\n\t\t\tvarying vec4 vSpriteSheet;\n\t\t#endif\n\t",l="\n\t\tfloat when_gt(float x, float y) {\n\t\t\treturn max(sign(x - y), 0.0);\n\t\t}\n\n\t\tfloat when_lt(float x, float y) {\n\t\t\treturn min( max(1.0 - sign(x - y), 0.0), 1.0 );\n\t\t}\n\n\t\tfloat when_eq(float x, float y) {\n\t\t\treturn 1.0 - abs(sign(x - y));\n\t\t}\n\n\t\tfloat when_ge(float x, float y) {\n\t\t\treturn 1.0 - when_lt(x, y);\n\t\t}\n\n\t\tfloat when_le(float x, float y) {\n\t\t\treturn 1.0 - when_gt(x, y);\n\t\t}\n\n\t\tfloat and(float a, float b) {\n\t\t\treturn a * b;\n\t\t}\n\n\t\tfloat or(float a, float b) {\n\t\t\treturn min(a + b, 1.0);\n\t\t}\n\t",u="\n\t\tvec3 unpackColor(in float hex) {\n\t\t\tvec3 c = vec3(0.0);\n\t\t\tfloat r = mod((hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE);\n\t\t\tfloat g = mod((hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE);\n\t\t\tfloat b = mod(hex, PACKED_COLOR_SIZE);\n\n\t\t\tc.r = r / PACKED_COLOR_DIVISOR;\n\t\t\tc.g = g / PACKED_COLOR_DIVISOR;\n\t\t\tc.b = b / PACKED_COLOR_DIVISOR;\n\n\t\t\treturn c;\n\t\t}\n\t",c="\n\t\tvec3 unpackRotationAxis(in float hex) {\n\t\t\t vec3 c = vec3(0.0);\n\n\t\t\t float r = mod((hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE);\n\t\t\t float g = mod((hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE);\n\t\t\t float b = mod(hex, PACKED_COLOR_SIZE);\n\n\t\t\t c.r = r / PACKED_COLOR_DIVISOR;\n\t\t\t c.g = g / PACKED_COLOR_DIVISOR;\n\t\t\t c.b = b / PACKED_COLOR_DIVISOR;\n\n\t\t\t c *= vec3(2.0);\n\t\t\t c -= vec3(1.0);\n\n\t\t\t return c;\n\t\t}\n\t",h="\n\t\tfloat getFloatOverLifetime(in float positionInTime, in vec4 attr) {\n\t\t\tfloat value = 0.0;\n\t\t\tfloat deltaAge = positionInTime * float(VALUE_OVER_LIFETIME_LENGTH - 1);\n\t\t\tfloat fIndex = 0.0;\n\t\t\tfloat shouldApplyValue = 0.0;\n\n\t\t\t// Fix for static emitters (age is always zero).\n\t\t\tvalue += attr[0] * when_eq(deltaAge, 0.0);\n\n\t\t\tfor(int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i) {\n\t\t\t\tfIndex = float(i);\n\t\t\t\tshouldApplyValue = and(when_gt(deltaAge, fIndex), when_le(deltaAge, fIndex + 1.0));\n\t\t\t\tvalue += shouldApplyValue * mix(attr[i], attr[i + 1], deltaAge - fIndex);\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\t",p="\n\t\tvec3 getColorOverLifetime(in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4) {\n\t\t\tvec3 value = vec3(0.0);\n\t\t\tvalue.x = getFloatOverLifetime(positionInTime, vec4(color1.x, color2.x, color3.x, color4.x));\n\t\t\tvalue.y = getFloatOverLifetime(positionInTime, vec4(color1.y, color2.y, color3.y, color4.y));\n\t\t\tvalue.z = getFloatOverLifetime(positionInTime, vec4(color1.z, color2.z, color3.z, color4.z));\n\t\t\treturn value;\n\t\t}\n\t",d="\n\t\tfloat getAlive() {\n\t\t\treturn params.x;\n\t\t}\n\n\t\tfloat getAge() {\n\t\t\treturn params.y;\n\t\t}\n\n\t\tfloat getMaxAge() {\n\t\t\treturn params.z;\n\t\t}\n\n\t\tfloat getWiggle() {\n\t\t\treturn params.w;\n\t\t}\n\t",f="\n\t\t#ifdef SHOULD_ROTATE_PARTICLES\n\t\t\tmat4 getRotationMatrix(in vec3 axis, in float angle) {\n\t\t\t\taxis = normalize(axis);\n\t\t\t\tfloat s = sin(angle);\n\t\t\t\tfloat c = cos(angle);\n\t\t\t\tfloat oc = 1.0 - c;\n\n\t\t\t\treturn mat4(\n\t\t\t\t\toc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0,\n\t\t\t\t\toc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n\t\t\t\t\toc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c, 0.0,\n\t\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tvec3 getRotation(in vec3 pos, in float positionInTime) {\n\t\t\t\tif(rotation.y == 0.0) {\n\t\t\t\t\treturn pos;\n\t\t\t\t}\n\n\t\t\t\tvec3 axis = unpackRotationAxis(rotation.x);\n\t\t\t\tvec3 center = rotationCenter;\n\t\t\t\tvec3 translated;\n\t\t\t\tmat4 rotationMatrix;\n\n\t\t\t\tfloat angle = 0.0;\n\t\t\t\tangle += when_eq(rotation.z, 0.0) * rotation.y;\n\t\t\t\tangle += when_gt(rotation.z, 0.0) * mix(0.0, rotation.y, positionInTime);\n\t\t\t\ttranslated = rotationCenter - pos;\n\t\t\t\trotationMatrix = getRotationMatrix(axis, angle);\n\t\t\t\treturn center - vec3(rotationMatrix * vec4(translated, 0.0));\n\t\t\t}\n\t\t#endif\n\t",g="\n\t\tvec2 vUv = vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y);\n\n\t\t// Spritesheets overwrite angle calculations.\n\t\t#ifdef SHOULD_CALCULATE_SPRITE\n\t\t\tfloat framesX = vSpriteSheet.x;\n\t\t\tfloat framesY = vSpriteSheet.y;\n\t\t\tfloat columnNorm = vSpriteSheet.z;\n\t\t\tfloat rowNorm = vSpriteSheet.w;\n\n\t\t\tvUv.x = gl_PointCoord.x * framesX + columnNorm;\n\t\t\tvUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);\n\t\t#endif\n\n\t\t#ifdef SHOULD_ROTATE_TEXTURE\n\t\t\t#ifdef SHOULD_CALCULATE_SPRITE\n\t\t\t\tfloat x = vUv.x - framesX * 0.5 - columnNorm;\n\t\t\t\tfloat y = vUv.y - (1.0 - rowNorm) + framesY * 0.5;\n\t\t\t\tfloat c = cos(-vAngle);\n\t\t\t\tfloat s = sin(-vAngle);\n\n\t\t\t\tvUv = vec2(c * x + s * y + framesX * 0.5 + columnNorm, c * y - s * x + (1.0 - rowNorm) - framesY * 0.5);\n\t\t\t#else\n\t\t\t\tfloat x = vUv.x - 0.5;\n\t\t\t\tfloat y = vUv.y - 0.5;\n\t\t\t\tfloat c = cos(-vAngle);\n\t\t\t\tfloat s = sin(-vAngle);\n\n\t\t\t\tvUv = vec2(c * x + s * y + 0.5, c * y - s * x + 0.5);\n\t\t\t#endif\n\t\t#endif\n\n\t\tvec4 rotatedTexture = texture2D(tex, vUv);\n\t",m={name:"particle_shader",defines:{HAS_PERSPECTIVE:!0,COLORIZE:!0,VALUE_OVER_LIFETIME_LENGTH:4,SHOULD_ROTATE_TEXTURE:!1,SHOULD_ROTATE_PARTICLES:!1,SHOULD_WIGGLE_PARTICLES:!1,SHOULD_CALCULATE_SPRITE:!1},uniforms:{tex:null,textureAnimation:[1,1,1,1],scale:300,deltaTime:0,runTime:0},vertexShader:`\n\t\t${"\n\t\t#define PACKED_COLOR_SIZE 256.0\n\t\t#define PACKED_COLOR_DIVISOR 255.0\n\t"}\n\t\t${o}\n\t\t${"\n\t\tattribute vec4 acceleration;\n\t\tattribute vec3 velocity;\n\t\tattribute vec4 rotation;\n\t\tattribute vec3 rotationCenter;\n\t\tattribute vec4 params;\n\t\tattribute vec4 size;\n\t\tattribute vec4 angle;\n\t\tattribute vec4 color;\n\t\tattribute vec4 opacity;\n\t"}\n\t\t${s}\n\n\t\t${e.ShaderChunk.common_vert}\n\t\t${e.ShaderChunk.logdepthbuf_pars_vert}\n\n\t\t${l}\n\t\t${u}\n\t\t${c}\n\t\t${h}\n\t\t${p}\n\t\t${d}\n\t\t${f}\n\n\t\tvoid main() {\n\t\t\t//\n\t\t\t// Setup...\n\t\t\t//\n\n\t\t\tfloat age = getAge();\n\t\t\tfloat alive = getAlive();\n\t\t\tfloat maxAge = getMaxAge();\n\t\t\tfloat positionInTime = (age / maxAge);\n\t\t\tfloat isAlive = when_gt(alive, 0.0);\n\n\t\t\t#ifdef SHOULD_WIGGLE_PARTICLES\n\t\t\t\tfloat wiggleAmount = positionInTime * getWiggle();\n\t\t\t\tfloat wiggleSin = isAlive * sin(wiggleAmount);\n\t\t\t\tfloat wiggleCos = isAlive * cos(wiggleAmount);\n\t\t\t#endif\n\n\t\t\t//\n\t\t\t// Forces\n\t\t\t//\n\n\t\t\t// Get forces\n\t\t\tvec3 vel = velocity;\n\t\t\tvec3 acc= acceleration.xyz;\n\n\t\t\t// Calculate the required drag to apply to the forces.\n\t\t\tfloat drag = 1.0 - (positionInTime * 0.5) * acceleration.w;\n\t\t\tvel *= drag;\n\n\t\t\tvec3 pos = vec3(a_Position);\n\t\t\tpos += vel * age;\n\t\t\tpos += acc * age * age * 0.5;\n\n\t\t\t// Wiggly wiggly wiggle!\n\t\t\t#ifdef SHOULD_WIGGLE_PARTICLES\n\t\t\t\tpos.x += wiggleSin;\n\t\t\t\tpos.y += wiggleCos;\n\t\t\t\tpos.z += wiggleSin;\n\t\t\t#endif\n\n\t\t\t// Rotate the emitter around it's central point\n\t\t\t#ifdef SHOULD_ROTATE_PARTICLES\n\t\t\t\tpos = getRotation(pos, positionInTime);\n\t\t\t#endif\n\n\t\t\t// Convert pos to a world-space value\n\t\t\tvec4 mvPosition = u_View * u_Model * vec4(pos, 1.0);\n\n\t\t\t// Determine point size.\n\t\t\tfloat pointSize = getFloatOverLifetime(positionInTime, size) * isAlive;\n\n\t\t\t// Determine perspective\n\t\t\t#ifdef HAS_PERSPECTIVE\n\t\t\t\tfloat perspective = scale / length(mvPosition.xyz);\n\t\t\t#else\n\t\t\t\tfloat perspective = 1.0;\n\t\t\t#endif\n\n\t\t\t// Apply perpective to pointSize value\n\t\t\tfloat pointSizePerspective = pointSize * perspective;\n\n\t\t\t//\n\t\t\t// Appearance\n\t\t\t//\n\n\t\t\t// Determine color and opacity for this particle\n\t\t\t#ifdef COLORIZE\n\t\t\t\tvec3 c = isAlive * getColorOverLifetime(\n\t\t\t\t\tpositionInTime,\n\t\t\t\t\tunpackColor(color.x),\n\t\t\t\t\tunpackColor(color.y),\n\t\t\t\t\tunpackColor(color.z),\n\t\t\t\t\tunpackColor(color.w)\n\t\t\t\t);\n\t\t\t#else\n\t\t\t\tvec3 c = vec3(1.0);\n\t\t\t#endif\n\n\t\t\tfloat o = isAlive * getFloatOverLifetime(positionInTime, opacity);\n\n\t\t\t// Assign color to vColor varying.\n\t\t\tvColor = vec4(c, o);\n\n\t\t\t// Determine angle\n\t\t\t#ifdef SHOULD_ROTATE_TEXTURE\n\t\t\t\tvAngle = isAlive * getFloatOverLifetime(positionInTime, angle);\n\t\t\t#endif\n\n\t\t\t// If this particle is using a sprite-sheet as a texture, we'll have to figure out\n\t\t\t// what frame of the texture the particle is using at it's current position in time.\n\t\t\t#ifdef SHOULD_CALCULATE_SPRITE\n\t\t\t\tfloat framesX = textureAnimation.x;\n\t\t\t\tfloat framesY = textureAnimation.y;\n\t\t\t\tfloat loopCount = textureAnimation.w;\n\t\t\t\tfloat totalFrames = textureAnimation.z;\n\t\t\t\tfloat frameNumber = mod((positionInTime * loopCount) * totalFrames, totalFrames);\n\n\t\t\t\tfloat column = floor(mod(frameNumber, framesX));\n\t\t\t\tfloat row = floor((frameNumber - column) / framesX);\n\n\t\t\t\tfloat columnNorm = column / framesX;\n\t\t\t\tfloat rowNorm = row / framesY;\n\n\t\t\t\tvSpriteSheet.x = 1.0 / framesX;\n\t\t\t\tvSpriteSheet.y = 1.0 / framesY;\n\t\t\t\tvSpriteSheet.z = columnNorm;\n\t\t\t\tvSpriteSheet.w = rowNorm;\n\t\t\t#endif\n\n\t\t\t//\n\t\t\t// Write values\n\t\t\t//\n\n\t\t\t// Set PointSize according to size at current point in time.\n\t\t\tgl_PointSize = pointSizePerspective;\n\t\t\tgl_Position = u_Projection * mvPosition;\n\n\t\t\t${e.ShaderChunk.logdepthbuf_vert}\n\t\t}\n\t`,fragmentShader:`\n\t\t${o}\n\n\t\t${e.ShaderChunk.common_frag}\n\t\t${e.ShaderChunk.fog_pars_frag}\n\t\t${e.ShaderChunk.logdepthbuf_pars_frag}\n\n\t\t${s}\n\n\t\t${l}\n\n\t\tvoid main() {\n\t\t\tvec3 outgoingLight = vColor.xyz;\n\n\t\t\t${g}\n\n\t\t\t${e.ShaderChunk.logdepthbuf_frag}\n\n\t\t\toutgoingLight = vColor.xyz * rotatedTexture.xyz;\n\t\t\tgl_FragColor = vec4(outgoingLight.xyz, rotatedTexture.w * vColor.w);\n\n\t\t\t#ifdef ALPHATEST\n\t\t\t\tif (gl_FragColor.a < float(ALPHATEST)) discard;\n\t\t\t#endif\n\n\t\t\t${e.ShaderChunk.fog_frag}\n\t\t}\n\t`};class _{constructor(t){this.uuid=r.generateUUID();const e=a.types,i=n.valueOverLifetimeLength;(t=a.ensureTypedArg(t,e.OBJECT,{})).position=a.ensureTypedArg(t.position,e.OBJECT,{}),t.velocity=a.ensureTypedArg(t.velocity,e.OBJECT,{}),t.acceleration=a.ensureTypedArg(t.acceleration,e.OBJECT,{}),t.radius=a.ensureTypedArg(t.radius,e.OBJECT,{}),t.drag=a.ensureTypedArg(t.drag,e.OBJECT,{}),t.rotation=a.ensureTypedArg(t.rotation,e.OBJECT,{}),t.color=a.ensureTypedArg(t.color,e.OBJECT,{}),t.opacity=a.ensureTypedArg(t.opacity,e.OBJECT,{}),t.size=a.ensureTypedArg(t.size,e.OBJECT,{}),t.angle=a.ensureTypedArg(t.angle,e.OBJECT,{}),t.wiggle=a.ensureTypedArg(t.wiggle,e.OBJECT,{}),t.maxAge=a.ensureTypedArg(t.maxAge,e.OBJECT,{}),this.type=a.ensureTypedArg(t.type,e.NUMBER,n.distributions.BOX),this.position={_value:a.ensureInstanceOf(t.position.value,r.Vector3,new r.Vector3),_spread:a.ensureInstanceOf(t.position.spread,r.Vector3,new r.Vector3),_spreadClamp:a.ensureInstanceOf(t.position.spreadClamp,r.Vector3,new r.Vector3),_distribution:t.position.distribution||this.type,_randomise:a.ensureTypedArg(t.position.randomise,e.BOOLEAN,!1),_radius:a.ensureTypedArg(t.position.radius,e.NUMBER,10),_radiusScale:a.ensureInstanceOf(t.position.radiusScale,r.Vector3,new r.Vector3(1,1,1))},this._setDistributeFunctions("position",this.position._distribution),this.velocity={_value:a.ensureInstanceOf(t.velocity.value,r.Vector3,new r.Vector3),_spread:a.ensureInstanceOf(t.velocity.spread,r.Vector3,new r.Vector3),_distribution:t.velocity.distribution||this.type,_randomise:a.ensureTypedArg(t.velocity.randomise,e.BOOLEAN,!1)},this._setDistributeFunctions("velocity",this.velocity._distribution),this.acceleration={_value:a.ensureInstanceOf(t.acceleration.value,r.Vector3,new r.Vector3),_spread:a.ensureInstanceOf(t.acceleration.spread,r.Vector3,new r.Vector3),_distribution:t.acceleration.distribution||this.type,_randomise:a.ensureTypedArg(t.acceleration.randomise,e.BOOLEAN,!1)},this._setDistributeFunctions("acceleration",this.acceleration._distribution),this.drag={_value:a.ensureTypedArg(t.drag.value,e.NUMBER,0),_spread:a.ensureTypedArg(t.drag.spread,e.NUMBER,0),_randomise:a.ensureTypedArg(t.drag.randomise,e.BOOLEAN,!1)},this.wiggle={_value:a.ensureTypedArg(t.wiggle.value,e.NUMBER,0),_spread:a.ensureTypedArg(t.wiggle.spread,e.NUMBER,0)},this.rotation={_axis:a.ensureInstanceOf(t.rotation.axis,r.Vector3,new r.Vector3(0,1,0)),_axisSpread:a.ensureInstanceOf(t.rotation.axisSpread,r.Vector3,new r.Vector3),_angle:a.ensureTypedArg(t.rotation.angle,e.NUMBER,0),_angleSpread:a.ensureTypedArg(t.rotation.angleSpread,e.NUMBER,0),_static:a.ensureTypedArg(t.rotation.static,e.BOOLEAN,!1),_center:a.ensureInstanceOf(t.rotation.center,r.Vector3,this.position._value.clone()),_randomise:a.ensureTypedArg(t.rotation.randomise,e.BOOLEAN,!1)},this.maxAge={_value:a.ensureTypedArg(t.maxAge.value,e.NUMBER,2),_spread:a.ensureTypedArg(t.maxAge.spread,e.NUMBER,0)},this.color={_value:a.ensureArrayInstanceOf(t.color.value,r.Color3,new r.Color3(1,1,1)),_spread:a.ensureArrayInstanceOf(t.color.spread,r.Vector3,new r.Vector3),_randomise:a.ensureTypedArg(t.color.randomise,e.BOOLEAN,!1)},this.opacity={_value:a.ensureArrayTypedArg(t.opacity.value,e.NUMBER,1),_spread:a.ensureArrayTypedArg(t.opacity.spread,e.NUMBER,0),_randomise:a.ensureTypedArg(t.opacity.randomise,e.BOOLEAN,!1)},this.size={_value:a.ensureArrayTypedArg(t.size.value,e.NUMBER,1),_spread:a.ensureArrayTypedArg(t.size.spread,e.NUMBER,0),_randomise:a.ensureTypedArg(t.size.randomise,e.BOOLEAN,!1)},this.angle={_value:a.ensureArrayTypedArg(t.angle.value,e.NUMBER,0),_spread:a.ensureArrayTypedArg(t.angle.spread,e.NUMBER,0),_randomise:a.ensureTypedArg(t.angle.randomise,e.BOOLEAN,!1)},this.resetFlags={position:a.ensureTypedArg(t.position.randomise,e.BOOLEAN,!1)||a.ensureTypedArg(t.radius.randomise,e.BOOLEAN,!1),velocity:a.ensureTypedArg(t.velocity.randomise,e.BOOLEAN,!1),acceleration:a.ensureTypedArg(t.acceleration.randomise,e.BOOLEAN,!1)||a.ensureTypedArg(t.drag.randomise,e.BOOLEAN,!1),rotation:a.ensureTypedArg(t.rotation.randomise,e.BOOLEAN,!1),size:a.ensureTypedArg(t.size.randomise,e.BOOLEAN,!1),color:a.ensureTypedArg(t.color.randomise,e.BOOLEAN,!1),opacity:a.ensureTypedArg(t.opacity.randomise,e.BOOLEAN,!1),angle:a.ensureTypedArg(t.angle.randomise,e.BOOLEAN,!1)},this.updateFlags={},this.updateCounts={},this.updateMap={maxAge:"params",position:"position",velocity:"velocity",acceleration:"acceleration",drag:"acceleration",wiggle:"params",rotation:"rotation",size:"size",color:"color",opacity:"opacity",angle:"angle"};for(const t in this.updateMap)this.updateMap.hasOwnProperty(t)&&(this.updateCounts[this.updateMap[t]]=0,this.updateFlags[this.updateMap[t]]=!1,this._createGetterSetters(this[t],t));a.ensureValueOverLifetimeCompliance(this.color,i,i),a.ensureValueOverLifetimeCompliance(this.opacity,i,i),a.ensureValueOverLifetimeCompliance(this.size,i,i),a.ensureValueOverLifetimeCompliance(this.angle,i,i),this.particleCount=a.ensureTypedArg(t.particleCount,e.NUMBER,100),this.duration=a.ensureTypedArg(t.duration,e.NUMBER,null),this.isStatic=a.ensureTypedArg(t.isStatic,e.BOOLEAN,!1),this.activeMultiplier=a.ensureTypedArg(t.activeMultiplier,e.NUMBER,1),this.direction=a.ensureTypedArg(t.direction,e.NUMBER,1),this.isLookAtCamera=a.ensureTypedArg(t.isLookAtCamera,e.BOOLEAN,!1),this.isLookAtCameraOnlyY=a.ensureTypedArg(t.isLookAtCameraOnlyY,e.BOOLEAN,!1),this.alive=a.ensureTypedArg(t.alive,e.BOOLEAN,!0),this.particlesPerSecond=0,this.calculatePPSValue(),this.age=0,this.group=null}_createGetterSetters(t,e){const i=this;for(const r in t)if(t.hasOwnProperty(r)){const o=r.replace("_","");Object.defineProperty(t,o,{get:function(t){return function(){return this[t]}}(r),set:function(t){return function(r){const o=i.updateMap[e],s=this[t],l=n.valueOverLifetimeLength;"_randomise"===t?i.resetFlags[o]=r:("_distribution"===t&&i._setDistributeFunctions(o,r),i.updateFlags[o]=!0,i.updateCounts[o]=0),this[t]=r,i.group.$updateDefines(i),Array.isArray(s)&&a.ensureValueOverLifetimeCompliance(i[e],l,l)}}(r)})}}calculatePPSValue(){const t=this.particleCount,e=this.maxAge._value+Math.abs(.5*this.maxAge._spread);return null!==this.duration?this.particlesPerSecond=t/Math.min(e,this.duration):this.particlesPerSecond=t/e,this}enable(){return this.alive=!0,this}disable(){return this.alive=!1,this}remove(){return null!==this.group?this.group.removeEmitter(this):console.error("Emitter does not belong to a group, cannot remove."),this}reset(t){}_assignValue(){}_assignPositionValue(t,e){const i=this.position,r=i._value,n=i._spread,a=i._spreadClamp;return i._getDistributionFunction(t,e,r,n,a,i._radius,i._radiusScale),t}_assignForceValue(t,e,i,r){const n=this[i],o=n._value,s=n._spread;if(n._getDistributionFunction(t,e,o,s,r[0],r[1],r[2],this.position._value),"acceleration"===i){const i=a.clamp(a.randomFloat(this.drag._value,this.drag._spread),0,1);t[e+3]=i}return t}_assignAbsLifetimeValue(t,e,i){const r=this[i];if(a.arrayValuesAreEqual(r._value)&&a.arrayValuesAreEqual(r._spread)){const i=Math.abs(a.randomFloat(r._value[0],r._spread[0]));t[e+0]=i,t[e+1]=i,t[e+2]=i,t[e+3]=i}else t[e+0]=Math.abs(a.randomFloat(r._value[0],r._spread[0])),t[e+1]=Math.abs(a.randomFloat(r._value[1],r._spread[1])),t[e+2]=Math.abs(a.randomFloat(r._value[2],r._spread[2])),t[e+3]=Math.abs(a.randomFloat(r._value[3],r._spread[3]));return t}_assignAngleValue(t,e){const i=this.angle;if(a.arrayValuesAreEqual(i._value)&&a.arrayValuesAreEqual(i._spread)){const r=a.randomFloat(i._value[0],i._spread[0]);t[e+0]=r,t[e+1]=r,t[e+2]=r,t[e+3]=r}else t[e+0]=a.randomFloat(i._value[0],i._spread[0]),t[e+1]=a.randomFloat(i._value[1],i._spread[1]),t[e+2]=a.randomFloat(i._value[2],i._spread[2]),t[e+3]=a.randomFloat(i._value[3],i._spread[3]);return t}_assignParamsValue(t,e,i){return t[e+0]=i?this.isStatic?1:0:1,t[e+1]=0,t[e+2]=a.randomFloat(this.maxAge._value,this.maxAge._spread),t[e+3]=a.randomFloat(this.wiggle._value,this.wiggle._spread),t}_assignRotationValue(t,e,i,r,n){const o=a.getRotationAxis(y,this.rotation._axis,this.rotation._axisSpread);n?(o.x+=1,o.y+=1,o.z+=1,o.multiplyScalar(.5),v.setRGB(o.x,o.y,o.z),t[e+0]=v.getHex(),t[e+1]=a.randomFloat(this.rotation._angle,this.rotation._angleSpread),t[e+2]=this.rotation._static?0:1):(t[e+0]=o.x,t[e+1]=o.y,t[e+2]=o.z,t[e+3]=a.randomFloat(this.rotation._angle,this.rotation._angleSpread),t[e+4]=this.rotation._static?0:1),this.rotation._center.toArray(i,r)}_assignColorValue(t,e,i){const r=this.color._value,n=this.color._spread,o=r.length;for(let s=0;s<o;++s){const o=n[s];v.copy(r[s]),v.r+=Math.random()*o.x-.5*o.x,v.g+=Math.random()*o.y-.5*o.y,v.b+=Math.random()*o.z-.5*o.z,v.r=a.clamp(v.r,0,1),v.g=a.clamp(v.g,0,1),v.b=a.clamp(v.b,0,1),i?t[e+s]=v.getHex():v.toArray(t,e+3*s)}}_setDistributeFunctions(t,e){this[t]._getDistributionFunction="function"==typeof e?e:A[t][e]}}const y=new r.Vector3,v=new r.Color3,A={position:{1:a.getRandomVector3,2:a.getRandomVector3OnSphere,3:a.getRandomVector3OnDisc,4:a.getRandomVector3OnLine},velocity:{1:a.getRandomVector3,2:a.getRandomDirectionVector3OnSphere,3:a.getRandomDirectionVector3OnDisc,4:a.getRandomVector3OnLine},acceleration:{1:a.getRandomVector3,2:a.getRandomDirectionVector3OnSphere,3:a.getRandomDirectionVector3OnDisc,4:a.getRandomVector3OnLine}};class x extends _{constructor(t){super(t),this.activationIndex=0,this.attributeOffset=0,this.attributeEnd=0,this.activeParticleCount=0,this.attributes=null,this.bufferUpdateRanges={},this.attributeKeys=null,this.attributeCount=0}tick(t){if(this.isStatic)return;const e=this.attributeOffset,i=e+this.particleCount,r=this.attributes.params.buffer.array,n=this.particlesPerSecond*this.activeMultiplier*t,a=this.activationIndex;if(this._resetBufferRanges(),this._checkParticleAges(e,i,r,t),!1===this.alive)return void(this.age=0);if(null!==this.duration&&this.age>this.duration)return this.alive=!1,void(this.age=0);const o=1===this.particleCount?a:0|a,s=Math.min(o+n,this.activationEnd),l=s-this.activationIndex|0,u=l>0?t/l:0;this._activateParticles(o,s,r,u),this.activationIndex+=n,this.activationIndex>i&&(this.activationIndex=e),this.age+=t}reset(t){if(this.age=0,this.alive=!1,!0===t){const t=this.attributeOffset,e=t+this.particleCount,i=this.attributes.params.buffer.array,r=this.attributes.params;for(let r,n=e-1;n>=t;--n)r=4*n,i[r]=0,i[r+1]=0;r.updateRange.offset=0,r.updateRange.count=-1,r.needsUpdate=!0}return this}_assignValue(t,e,i=!1){let r,n,a,o,s;switch(t){case"position":r=this.attributes.position.buffer.array,this._assignPositionValue(r,this.attributes.position.size*e);break;case"velocity":case"acceleration":r=this.attributes.position.buffer.array,a=r[3*e+0],o=r[3*e+1],s=r[3*e+2],r=this.attributes[t].buffer.array,this._assignForceValue(r,this.attributes[t].size*e,t,[a,o,s]);break;case"size":case"opacity":r=this.attributes[t].buffer.array,this._assignAbsLifetimeValue(r,this.attributes[t].size*e,t);break;case"angle":r=this.attributes.angle.buffer.array,this._assignAngleValue(r,this.attributes.angle.size*e);break;case"params":r=this.attributes.params.buffer.array,this._assignParamsValue(r,this.attributes.params.size*e,i);break;case"rotation":r=this.attributes.rotation.buffer.array,n=this.attributes.rotationCenter.buffer.array,this._assignRotationValue(r,this.attributes.rotation.size*e,n,this.attributes.rotationCenter.size*e,!0);break;case"color":r=this.attributes.color.buffer.array,this._assignColorValue(r,this.attributes.color.size*e,!0)}}_resetParticle(t){const e=this.resetFlags,i=this.updateFlags,r=this.updateCounts,n=this.attributeKeys;let a,o;for(let s=this.attributeCount-1;s>=0;--s)a=n[s],o=i[a],!0!==e[a]&&!0!==o||(this._assignValue(a,t),this._updateAttributeUpdateRange(a,t),!0===o&&r[a]===this.particleCount?(i[a]=!1,r[a]=0):1==o&&++r[a])}_setBufferUpdateRanges(t){this.attributeKeys=t,this.attributeCount=t.length;for(let e=this.attributeCount-1;e>=0;--e)this.bufferUpdateRanges[t[e]]={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY}}_setAttributeOffset(t){this.attributeOffset=t,this.activationIndex=t,this.activationEnd=t+this.particleCount}_updateAttributeUpdateRange(t,e){const i=this.bufferUpdateRanges[t];i.min=Math.min(e,i.min),i.max=Math.max(e,i.max),"rotation"===t&&this._updateAttributeUpdateRange("rotationCenter",e)}_resetBufferRanges(){const t=this.bufferUpdateRanges,e=this.bufferUpdateKeys;let i,r=this.bufferUpdateCount-1;for(;r>=0;--r)i=e[r],t[i].min=Number.POSITIVE_INFINITY,t[i].max=Number.NEGATIVE_INFINITY}_onRemove(){this.particlesPerSecond=0,this.attributeOffset=0,this.activationIndex=0,this.activeParticleCount=0,this.group=null,this.attributes=null,this.age=0}_decrementParticleCount(){--this.activeParticleCount}_incrementParticleCount(){++this.activeParticleCount}_checkParticleAges(t,e,i,r){for(let n,a,o,s,l=e-1;l>=t;--l)n=4*l,s=i[n],0!==s&&(o=i[n+1],a=i[n+2],1===this.direction?(o+=r,o>=a&&(o=0,s=0,this._decrementParticleCount())):(o-=r,o<=0&&(o=a,s=0,this._decrementParticleCount())),i[n]=s,i[n+1]=o,this._updateAttributeUpdateRange("params",l))}_activateParticles(t,e,i,r){const n=this.direction;for(let a,o,s=t;s<e;++s)a=4*s,0!=i[a]&&1!==this.particleCount||(this._incrementParticleCount(),i[a]=1,this._resetParticle(s),o=r*(s-t),i[a+1]=-1===n?i[a+2]-o:o,this._updateAttributeUpdateRange("params",s))}}class E{constructor(t,e){this.uuid=r.generateUUID();const i=a.types;t.texture=a.ensureTypedArg(t.texture,i.OBJECT,{}),this.fixedTimeStep=a.ensureTypedArg(t.fixedTimeStep,i.NUMBER,.016),this.hasPerspective=a.ensureTypedArg(t.hasPerspective,i.BOOLEAN,!0),this.colorize=a.ensureTypedArg(t.colorize,i.BOOLEAN,!0),this.material=new r.ShaderMaterial(e),this.uniforms=this.material.uniforms,this.defines=this.material.defines,this.setTextureValue(t.texture.value),this.material.blending=a.ensureTypedArg(t.blending,i.STRING,r.BLEND_TYPE.ADD),this.material.transparent=a.ensureTypedArg(t.transparent,i.BOOLEAN,!0),this.material.alphaTest=a.ensureTypedArg(t.alphaTest,i.NUMBER,0),this.material.depthWrite=a.ensureTypedArg(t.depthWrite,i.BOOLEAN,!1),this.material.depthTest=a.ensureTypedArg(t.depthTest,i.BOOLEAN,!0),this.material.fog=a.ensureTypedArg(t.fog,i.BOOLEAN,!0),this._emitters=[]}addEmitter(t){}removeEmitter(t){}tick(t){}dispose(){}setTextureValue(t){this.uniforms.tex=a.ensureInstanceOf(t,r.Texture2D,b)}}const b=new r.Texture2D;b.image={data:new Uint8Array([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255]),width:2,height:2},b.magFilter=r.TEXTURE_FILTER.NEAREST,b.minFilter=r.TEXTURE_FILTER.NEAREST,b.generateMipmaps=!1;const C={position:3,acceleration:4,velocity:3,rotation:4,rotationCenter:3,params:4,size:4,angle:4,color:4,opacity:4};class O extends E{constructor(t){const e=a,i=e.types;super(t=a.ensureTypedArg(t,i.OBJECT,{}),m),this.maxParticleCount=e.ensureTypedArg(t.maxParticleCount,i.NUMBER,null),null===this.maxParticleCount&&console.warn("ParticleGroup: No maxParticleCount specified. Adding emitters after rendering will probably cause errors."),this.textureFrames=a.ensureInstanceOf(t.texture.frames,r.Vector2,new r.Vector2(1,1)),this.textureFrames.max(new r.Vector2(1,1)),this.textureFrameCount=a.ensureTypedArg(t.texture.frameCount,i.NUMBER,this.textureFrames.x*this.textureFrames.y),this.textureLoop=a.ensureTypedArg(t.texture.loop,i.NUMBER,1),this.defines.HAS_PERSPECTIVE=this.hasPerspective,this.defines.COLORIZE=this.colorize,this.defines.VALUE_OVER_LIFETIME_LENGTH=n.valueOverLifetimeLength,this.defines.SHOULD_CALCULATE_SPRITE=this.textureFrames.x>1||this.textureFrames.y>1,this.uniforms.textureAnimation=[this.textureFrames.x,this.textureFrames.y,this.textureFrameCount,Math.max(Math.abs(this.textureLoop),1)],this.uniforms.scale=e.ensureTypedArg(t.scale,i.NUMBER,300),this.material.drawMode=r.DRAW_MODE.POINTS,this.geometry=new r.Geometry,this.geometry.addGroup(0,this.particleCount,0),this.attributes={position:null,acceleration:null,velocity:null,rotation:null,rotationCenter:null,params:null,size:null,angle:null,color:null,opacity:null},this.attributeKeys=Object.keys(this.attributes),this.attributeCount=this.attributeKeys.length,this._attributesNeedRefresh=!1,this._attributesNeedDynamicReset=!1,this.mesh=new r.Mesh(this.geometry,[this.material]),this.mesh.frustumCulled=!1,this.particleCount=0}addEmitter(t){if(t instanceof x==!1)return void console.error("`emitter` argument must be instance of ParticleEmitter. Was provided with:",t);if(this._emitters.indexOf(t)>-1)return void console.error("ParticleEmitter already exists in this group. Will not add again.");if(null!==t.group)return void console.error("ParticleEmitter already belongs to another group. Will not add to requested group.");const e=this.attributes,i=this.particleCount,n=i+t.particleCount;this.particleCount=n,null!==this.maxParticleCount&&this.particleCount>this.maxParticleCount&&console.warn("ParticleGroup: maxParticleCount exceeded. Requesting",this.particleCount,"particles, can support only",this.maxParticleCount),t._setBufferUpdateRanges(this.attributeKeys),t._setAttributeOffset(i),t.group=this,t.attributes=this.attributes;for(const t in e)if(e.hasOwnProperty(t)){const i=e[t],n=null!==this.maxParticleCount?this.maxParticleCount:this.particleCount;if(null!==i&&null!==i.buffer.array){if(i.buffer.array.length!==n*i.size){const t=i.buffer.array.length,e=n*i.size;if(e<t)i.buffer.array=i.buffer.array.subarray(0,e);else{const t=i.buffer.array,r=new Float32Array(e);r.set(t),i.buffer.array=r}i.buffer.count=n,i.buffer.version++}}else e[t]=new r.Attribute(new r.Buffer(new Float32Array(n*C[t]),C[t])),e[t].buffer.usage=r.BUFFER_USAGE.DYNAMIC_DRAW}for(let e=i;e<n;++e)t._assignValue("position",e,!0),t._assignValue("velocity",e,!0),t._assignValue("acceleration",e,!0),t._assignValue("size",e,!0),t._assignValue("opacity",e,!0),t._assignValue("angle",e,!0),t._assignValue("params",e,!0),t._assignValue("rotation",e,!0),t._assignValue("color",e,!0);return this._applyAttributesToGeometry(),this._emitters.push(t),this.$updateDefines(t),this._attributesNeedRefresh=!0,this}removeEmitter(t){const e=this._emitters.indexOf(t);if(t instanceof x==!1)return void console.error("`emitter` argument must be instance of ParticleEmitter. Was provided with:",t);if(-1===e)return void console.error("ParticleEmitter does not exist in this group. Will not remove.");const i=t.attributeOffset,r=i+t.particleCount,n=this.attributes.params.buffer.array;for(let t=i;t<r;++t)n[4*t]=0,n[4*t+1]=0;this._emitters.splice(e,1);for(const t in this.attributes)if(this.attributes.hasOwnProperty(t)){const e=this.attributes[t],n=i*e.size,a=r*e.size;let o=e.buffer.array;const s=[];for(let t=0;t<o.length;++t)(t<n||t>=a)&&s.push(o[t]);o=o.subarray(0,s.length),o.set(s),this.attributes[t].buffer.array=o}for(let i=this._emitters.length-1;i>=e;i--){const e=this._emitters[i].attributeOffset-t.particleCount;this._emitters[i]._setAttributeOffset(e)}this.particleCount-=t.particleCount,this.geometry.groups[0].count=this.particleCount,t._onRemove(),this._attributesNeedRefresh=!0}tick(t){const e=this._emitters,i=e.length,n=t||this.fixedTimeStep,a=this.attributeKeys,o=this.attributes;let s,l;if(this.uniforms.runTime+=n,this.uniforms.deltaTime=n,0!==i||!1!==this._attributesNeedRefresh||!1!==this._attributesNeedDynamicReset){for(l=0;l<i;++l)e[l].tick(n);for(s=this.attributeCount-1;s>=0;--s){const t=a[s];let r=1/0,n=-1/0;for(l=0;l<i;++l){const i=e[l].bufferUpdateRanges[t];r=Math.min(i.min,r),n=Math.max(i.max,n)}if(n-r>0){const e=o[t];e.buffer.updateRange.offset=r*e.size,e.buffer.updateRange.count=Math.min((n-r+1)*e.size,e.buffer.array.length),e.buffer.version++}}if(!0===this._attributesNeedDynamicReset){for(s=this.attributeCount-1;s>=0;--s)o[a[s]].buffer.usage=r.BUFFER_USAGE.DYNAMIC_DRAW;this._attributesNeedDynamicReset=!1}if(!0===this._attributesNeedRefresh){for(s=this.attributeCount-1;s>=0;--s)o[a[s]].buffer.updateRange.offset=0,o[a[s]].buffer.updateRange.count=-1,o[a[s]].buffer.usage=r.BUFFER_USAGE.STATIC_DRAW,o[a[s]].buffer.version++;this._attributesNeedRefresh=!1,this._attributesNeedDynamicReset=!0}}}dispose(){return this.mesh.geometry.dispose(),this.mesh.material[0].dispose(),this}$updateDefines(){const t=this._emitters,e=this.defines;let i,r=t.length-1;for(;r>=0;--r)i=t[r],e.SHOULD_ROTATE_TEXTURE=e.SHOULD_ROTATE_TEXTURE||a.hasNonZeroElement(i.angle.value)||a.hasNonZeroElement(i.angle.spread),e.SHOULD_ROTATE_PARTICLES=e.SHOULD_ROTATE_PARTICLES||0!==i.rotation.angle||0!==i.rotation.angleSpread,e.SHOULD_WIGGLE_PARTICLES=e.SHOULD_WIGGLE_PARTICLES||0!==i.wiggle.value||0!==i.wiggle.spread;this.material.needsUpdate=!0}_applyAttributesToGeometry(){const t=this.attributes,e=this.geometry,i=e.attributes;let r,n;for(const a in t)t.hasOwnProperty(a)&&(r=t[a],n=i["position"===a?"a_Position":a],n||e.addAttribute("position"===a?"a_Position":a,r));this.geometry.version++,this.geometry.groups[0].count=this.particleCount}}const T={name:"mesh_particle_shader",uniforms:{tex:null},vertexShader:"\n\t\t#include <common_vert>\n\n\t\tattribute vec3 mcol0;\n\t\tattribute vec3 mcol1;\n\t\tattribute vec3 mcol2;\n\t\tattribute vec3 mcol3;\n\t\tattribute vec4 color;\n\n\t\tattribute vec2 a_Uv;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 varyColor;\n\n\t\t#include <logdepthbuf_pars_vert>\n\n\t\tvoid main() {\n\t\t\tmat4 matrix = mat4(\n\t\t\t\tvec4(mcol0, 0),\n\t\t\t\tvec4(mcol1, 0),\n\t\t\t\tvec4(mcol2, 0),\n\t\t\t\tvec4(mcol3, 1)\n\t\t\t);\n\n\t\t\tvec4 worldPosition = u_Model * matrix * vec4(a_Position, 1.0);\n\t\t\tgl_Position = u_ProjectionView * worldPosition;\n\n\t\t\tvaryColor = color;\n\t\t\tvUv = a_Uv;\n\n\t\t\t#include <logdepthbuf_vert>\n\t\t}\n\t",fragmentShader:"\n\t\tuniform sampler2D tex;\n\n\t\t#include <common_frag>\n\t\t#include <fog_pars_frag>\n\t\t#include <logdepthbuf_pars_frag>\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 varyColor;\n\n\t\tvoid main() {\n\t\t\t#include <logdepthbuf_frag>\n\n\t\t\tgl_FragColor = varyColor * texture2D(tex, vUv);\n\n\t\t\t#ifdef ALPHATEST\n\t\t\t\tif (gl_FragColor.a < float(ALPHATEST)) discard;\n\t\t\t#endif\n\n\t\t\t#include <fog_frag>\n\t\t}\n\t"};class R{constructor(){this._matrix=new r.Matrix4,this._color=new r.Color3(1,1,1),this._opacity=1,this._originPosition=[0,0,0],this._originVelocity=[0,0,0],this._originAcceleration=[0,0,0,0],this._originOpacityArray=[],this._originSizeArray=[],this._originAngleArray=[],this._originColorArray=[1,1,1,1,1,1,1,1,1,1,1,1],this._originParams=[0,0,0,0],this._originRotation=[0,1,0,0,0],this._originRotationCenter=[0,0,0]}isAlive(){return!!this._originParams[0]}tick(t,e,i){this._originParams[1]+=t,this._originParams[1]>this._originParams[2]&&(this._originParams[0]=0),0!==this._originParams[0]?this._update(e,i):this._originParams[1]=0}submit(t,e){const i=16*e,r=this._matrix.elements;t[i]=r[0],t[i+1]=r[1],t[i+2]=r[2],t[i+3]=r[4],t[i+4]=r[5],t[i+5]=r[6],t[i+6]=r[8],t[i+7]=r[9],t[i+8]=r[10],t[i+9]=r[12],t[i+10]=r[13],t[i+11]=r[14],t[i+12]=this._color.r,t[i+13]=this._color.g,t[i+14]=this._color.b,t[i+15]=this._opacity}_update(t,e){const i=this._originParams[1],r=i/this._originParams[2],o=L.fromArray(this._originVelocity);if(e.SHOULD_DRAG_PARTICLES){const t=1-.5*r*this._originAcceleration[3];o.multiplyScalar(t)}const s=P.fromArray(this._originAcceleration);if(I.fromArray(this._originPosition).add(o.multiplyScalar(i)).add(s.multiplyScalar(i*i*.5)),e.SHOULD_WIGGLE_PARTICLES){const t=r*this._originParams[3]*Math.PI,e=Math.sin(t),i=Math.cos(t);I.x+=e,I.y+=i,I.z+=e}if(e.SHOULD_ROTATE_PARTICLES){const t=this._originRotation[3];if(0!==t){let e=0;e=0===this._originRotation[4]?t:a.lerp(0,t,r);const i=P.fromArray(this._originRotation),n=w.makeRotationAxis(i,e),o=P.fromArray(this._originRotationCenter).sub(I);o.applyMatrix4(n),I.fromArray(this._originRotationCenter).sub(o)}}if(V.set(1,1,1),e.SHOULD_SIZE_PARTICLES){const t=U(r,this._originSizeArray);V.set(t,t,t)}if(e.isLookAtCamera||e.isLookAtCameraOnlyY)e.isLookAtCamera?M.copy(t.quaternion):e.isLookAtCameraOnlyY&&(w.getInverse(e.group.mesh.worldMatrix),w.multiply(t.worldMatrix),P.setFromMatrixPosition(w),L.copy(I).sub(P),L.y=0,M.setFromUnitVectors(P.set(0,0,-1),L.normalize()));else if(e.SHOULD_ANGLE_PARTICLES){const t=U(r,this._originAngleArray);S.set(t,t,t),M.setFromEuler(S,!1)}this._matrix.transform(I,V,M),e.SHOULD_COLORIZE_PARTICLES?(!function(t,e,i){const r=n.valueOverLifetimeLength-1;if(t<=0)i.fromArray(e,0);else if(t>=1)i.fromArray(e,3*r);else{const n=t*r;let a,o,s;for(let t=0;t<r;t++)if(n>t&&n<t+1){a=n-t,o=3*t,s=o+3,i.r=a*(e[s+0]-e[o+0])+e[o+0],i.g=a*(e[s+1]-e[o+1])+e[o+1],i.b=a*(e[s+2]-e[o+2])+e[o+2];break}}}(r,this._originColorArray,this._color),this._opacity=U(r,this._originOpacityArray)):(this._color.setRGB(1,1,1),this._opacity=1)}}const P=new r.Vector3,L=new r.Vector3,S=new r.Euler,w=new r.Matrix4,I=new r.Vector3,M=new r.Quaternion,V=new r.Vector3;function U(t,e){const i=n.valueOverLifetimeLength-1;let r=0;if(t<=0)r=0;else if(t>=1)r=e[i];else{const n=t*i;for(let t=0;t<i;t++)if(n>t&&n<t+1){r+=a.lerp(e[t],e[t+1],n-t);break}}return r}class N extends _{constructor(t){super(t),this._activeParticles=new Array,this._particlePool=new Array,this._spawnDecimal=0}tick(t,e){if(this.isStatic){for(let t=0,e=this._activeParticles.length;t<e;t++)if(this._activeParticles[t].isAlive()){const e=this.group;this._activeParticles[t].submit(e.$instanceBuffer.array,e.$allocBufferIndex())}return}if(!1===this.alive)return void(this.age=0);const i=null!==this.duration&&this.age>this.duration;if(!i){const e=this._activeParticles.length,i=this.particlesPerSecond*this.activeMultiplier*t+this._spawnDecimal,r=Math.floor(i);this._spawnDecimal=i-r;const n=Math.min(e+r,this.particleCount)-e;for(let t=0;t<n;t++){const t=this._particlePool.length<=0?new R:this._particlePool.shift();this._resetParticle(t),this._activeParticles.push(t)}}for(let i=0,r=this._activeParticles.length;i<r;i++)if(this._activeParticles[i].tick(t,e,this),this._activeParticles[i].isAlive()){const t=this.group;this._activeParticles[i].submit(t.$instanceBuffer.array,t.$allocBufferIndex())}else this._particlePool.push(this._activeParticles[i]),this._activeParticles.splice(i,1),r--,i--;i&&this._activeParticles.length<=0&&(this.alive=!1,this.age=0),this.alive&&(this.age+=t)}_onRemove(){this.particlesPerSecond=0,this._spawnDecimal=0,this._group=null}reset(t){this.alive=!1,this.age=0,t&&(this._activeParticles=[],this._particlePool=[])}$updateFlags(t){this.SHOULD_DRAG_PARTICLES=!!Math.max(this.drag._value,this.drag._spread),this.SHOULD_WIGGLE_PARTICLES=!!Math.max(this.wiggle._value,this.wiggle._spread),this.SHOULD_ROTATE_PARTICLES=!!Math.max(this.rotation._angle,this.rotation._angleSpread),this.SHOULD_COLORIZE_PARTICLES=t.colorize,this.SHOULD_SIZE_PARTICLES=!0,this.SHOULD_ANGLE_PARTICLES=!0}_assignValue(t,e,i,r){switch(t){case"position":this._assignPositionValue(e,0);break;case"velocity":case"acceleration":this._assignForceValue(e,0,t,i);break;case"size":case"opacity":this._assignAbsLifetimeValue(e,0,t);break;case"angle":this._assignAngleValue(e,0);break;case"params":this._assignParamsValue(e,0);break;case"rotation":this._assignRotationValue(e,0,r,0);break;case"color":this._assignColorValue(e,0)}}_resetParticle(t){this._assignValue("position",t._originPosition),this._assignValue("velocity",t._originVelocity,t._originPosition),this._assignValue("acceleration",t._originAcceleration,t._originPosition),this._assignValue("opacity",t._originOpacityArray),this._assignValue("size",t._originSizeArray),this._assignValue("angle",t._originAngleArray),this._assignValue("color",t._originColorArray),this._assignValue("params",t._originParams),this._assignValue("rotation",t._originRotation,void 0,t._originRotationCenter)}}class B extends E{constructor(t){const e=a.types;super(t=a.ensureTypedArg(t,e.OBJECT,{}),T),void 0===t.maxParticleCount&&(console.warn("MeshParticleGroup: options.maxParticleCount is not provided, set to 1000 by default."),t.maxParticleCount=1e3),this.maxParticleCount=t.maxParticleCount,t.geometry&&t.geometry instanceof r.Geometry||(console.warn("MeshParticleGroup: options.geometry is not provided, set a box geometry by default."),t.geometry=new r.BoxGeometry(1,1,1));const i=function(t,e){const i=t.clone(),n=new r.Buffer(new Float32Array(16*e),16);n.usage=r.BUFFER_USAGE.DYNAMIC_DRAW;const a=new r.Attribute(n,3,0),o=new r.Attribute(n,3,3),s=new r.Attribute(n,3,6),l=new r.Attribute(n,3,9),u=new r.Attribute(n,4,12);return a.divisor=1,o.divisor=1,s.divisor=1,l.divisor=1,u.divisor=1,i.addAttribute("mcol0",a),i.addAttribute("mcol1",o),i.addAttribute("mcol2",s),i.addAttribute("mcol3",l),i.addAttribute("color",u),i}(t.geometry,this.maxParticleCount);this.$instanceBuffer=i.attributes.mcol0.buffer,this._geometry=i,this.mesh=new r.Mesh(i,this.material),this.mesh.frustumCulled=!1,this._particleCount=0,this._aliveParticleCount=0}addEmitter(t){if(t instanceof N!=!1)if(this._emitters.indexOf(t)>-1)console.error("MeshParticleEmitter already exists in this group. Will not add again.");else{if(null===t.group)return this._particleCount+=t.particleCount,this._particleCount>this.maxParticleCount&&console.warn("MeshParticleGroup: maxParticleCount exceeded. Requesting",this._particleCount,"particles, can support only",this.maxParticleCount),t.group=this,this._emitters.push(t),this.$updateDefines(t),this;console.error("MeshParticleEmitter already belongs to another group. Will not add to requested group.")}else console.error("`emitter` argument must be instance of MeshParticleEmitter. Was provided with:",t)}removeEmitter(t){const e=this._emitters.indexOf(t);if(t instanceof N!=!1){if(-1!==e)return this._particleCount-=t.particleCount,t._onRemove(),this._emitters.splice(e,1),this;console.error("MeshParticleEmitter does not exist in this group. Will not remove.")}else console.error("`emitter` argument must be instance of MeshParticleEmitter. Was provided with:",t)}tick(t,e){const i=this._emitters,r=i.length,n=t||this.fixedTimeStep;if(0!==r){this._aliveParticleCount=0;for(let t=0;t<r;t++)i[t].tick(n,e);this.$instanceBuffer.version++,this._geometry.instanceCount=this._aliveParticleCount}}dispose(){this.mesh.geometry.dispose(),this.mesh.material.dispose();for(let t=0,e=this._emitters.length;t<e;t++)this._emitters[t].group=null;return this._emitters=[],this._particleCount=0,this._aliveParticleCount=0,this}get particleCount(){return this._particleCount}get aliveParticleCount(){return this._aliveParticleCount}$updateDefines(t){t.$updateFlags(this)}$allocBufferIndex(){return this._aliveParticleCount++}}class D extends e.Loader{constructor(t){super(t),this.geometries={Plane:new z(1,1),Box:new e.BoxGeometry(1,1,1),Sphere:new e.SphereGeometry(1,20,20)},this._textureLoader=null}setTextureLoader(t){return this._textureLoader=t,this}load(t,i,r,n){const a=this,o=new e.FileLoader(a.manager);o.setPath(a.path),o.setResponseType("json"),o.setRequestHeader(a.requestHeader),o.setWithCredentials(a.withCredentials),o.load(t,(e=>{try{const t=a.parse(e);t.json=e,i(t)}catch(e){n?n(e):console.error(e),a.manager.itemError(t)}}),r,n)}parse(t){const i={groups:[]};return i.root=new e.Object3D,t.groups.forEach((t=>{const e=this.parseParticleGroup(t);i.groups.push(e),i.root.add(e.mesh)})),i}parseParticleCount(t){let e=0;return t.emitters.forEach((t=>{e+=t.particleCount})),e}parseParticleGroup(t,e=2e3){const i=1==t.mode,r=this._convertGroupData(t);let n;return r.maxParticleCount=e||this.parseParticleCount(t),i?(n=new B(r),n.isMeshParticleGroup=!0):(n=new O(r),n.isParticleGroup=!0),t.emitters.forEach((t=>{n.addEmitter(this.parseParticleEmitter(t,i))})),n}parseParticleEmitter(t,e=!1){const i=this._convertEmitterData(t);let r;return e?(r=new N(i),r.isMeshParticleEmitter=!0):(r=new x(i),r.isParticleEmitter=!0),r}_convertGroupData(t){const i=this.geometries,r=this._textureLoader,n={};if(1==t.mode){let e=t.meshUri;e.startsWith("BuildIn/")?e=e.substring(8):console.warn("Mesh particle group only support built-in geometries for now."),n.geometry=i[e]||i.Plane}else n.hasPerspective=t.perspective;return n.texture={value:null},t.textureUri&&(r?n.texture.value=r.load(t.textureUri):console.warn("ParticleLoader: No texture loader is set. Use `ParticleLoader.setTextureLoader` to set one.")),n.texture.frames=(new e.Vector2).fromArray(t.textureFrame),n.texture.loop=t.textureFrameLoop,n.colorize=t.colorize,n.transparent=t.transparent,n.blending=t.blending,n.alphaTest=t.alphaTest,n.depthWrite=t.depthWrite,n.depthTest=t.depthTest,n.side=t.side,n.fog=t.fog,n}_convertEmitterData(t){const e={};e.particleCount=t.particleCount,e.isStatic=t.isStatic,e.direction=t.direction,e.activeMultiplier=t.activeMultiplier,e.isLookAtCamera=1==t.meshAlignment,e.isLookAtCameraOnlyY=2==t.meshAlignment;["maxAge","position","velocity","acceleration","drag","wiggle","rotation"].forEach((i=>{e[i]=this._convertSimpleAttributeData(t[i])}));return["color","opacity","size","angle"].forEach((i=>{e[i]=this._convertArrayAttributeData(t[i])})),e}_convertSimpleAttributeData(t){const i={};return Object.keys(t).forEach((r=>{const n=t[r];Array.isArray(n)?i[r]=(new e.Vector3).fromArray(n):i[r]=n})),i}_convertArrayAttributeData(t){const i=[],r=[];return t.elements.forEach((t=>{i.push(Array.isArray(t.value)?(new e.Color3).fromArray(t.value):t.value),r.push(Array.isArray(t.spread)?(new e.Vector3).fromArray(t.spread):t.spread)})),{value:i,spread:r,randomise:t.randomise}}}class z extends e.Geometry{constructor(){super(),this.addAttribute("a_Position",new e.Attribute(new e.Buffer(new Float32Array([-.5,.5,0,.5,.5,0,-.5,-.5,0,.5,-.5,0]),3))),this.addAttribute("a_Uv",new e.Attribute(new e.Buffer(new Float32Array([0,1,1,1,0,0,1,0]),2))),this.addAttribute("a_Normal",new e.Attribute(new e.Buffer(new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1]),3))),this.setIndex(new e.Attribute(new e.Buffer(new Uint16Array([0,2,1,2,3,1]),1))),this.computeBoundingBox(),this.computeBoundingSphere()}}t.MeshParticleEmitter=N,t.MeshParticleGroup=B,t.ParticleEmitter=x,t.ParticleGroup=O,t.ParticleLoader=D,t.ParticleProperties=n}));
